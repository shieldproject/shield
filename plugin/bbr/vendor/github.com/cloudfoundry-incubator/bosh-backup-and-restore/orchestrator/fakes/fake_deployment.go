// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/cloudfoundry-incubator/bosh-backup-and-restore/orchestrator"
)

type FakeDeployment struct {
	IsBackupableStub        func() bool
	isBackupableMutex       sync.RWMutex
	isBackupableArgsForCall []struct{}
	isBackupableReturns     struct {
		result1 bool
	}
	isBackupableReturnsOnCall map[int]struct {
		result1 bool
	}
	HasUniqueCustomArtifactNamesStub        func() bool
	hasUniqueCustomArtifactNamesMutex       sync.RWMutex
	hasUniqueCustomArtifactNamesArgsForCall []struct{}
	hasUniqueCustomArtifactNamesReturns     struct {
		result1 bool
	}
	hasUniqueCustomArtifactNamesReturnsOnCall map[int]struct {
		result1 bool
	}
	CheckArtifactDirStub        func() error
	checkArtifactDirMutex       sync.RWMutex
	checkArtifactDirArgsForCall []struct{}
	checkArtifactDirReturns     struct {
		result1 error
	}
	checkArtifactDirReturnsOnCall map[int]struct {
		result1 error
	}
	IsRestorableStub        func() bool
	isRestorableMutex       sync.RWMutex
	isRestorableArgsForCall []struct{}
	isRestorableReturns     struct {
		result1 bool
	}
	isRestorableReturnsOnCall map[int]struct {
		result1 bool
	}
	PreBackupLockStub        func() error
	preBackupLockMutex       sync.RWMutex
	preBackupLockArgsForCall []struct{}
	preBackupLockReturns     struct {
		result1 error
	}
	preBackupLockReturnsOnCall map[int]struct {
		result1 error
	}
	BackupStub        func() error
	backupMutex       sync.RWMutex
	backupArgsForCall []struct{}
	backupReturns     struct {
		result1 error
	}
	backupReturnsOnCall map[int]struct {
		result1 error
	}
	PostBackupUnlockStub        func() error
	postBackupUnlockMutex       sync.RWMutex
	postBackupUnlockArgsForCall []struct{}
	postBackupUnlockReturns     struct {
		result1 error
	}
	postBackupUnlockReturnsOnCall map[int]struct {
		result1 error
	}
	RestoreStub        func() error
	restoreMutex       sync.RWMutex
	restoreArgsForCall []struct{}
	restoreReturns     struct {
		result1 error
	}
	restoreReturnsOnCall map[int]struct {
		result1 error
	}
	CopyRemoteBackupToLocalStub        func(orchestrator.Backup) error
	copyRemoteBackupToLocalMutex       sync.RWMutex
	copyRemoteBackupToLocalArgsForCall []struct {
		arg1 orchestrator.Backup
	}
	copyRemoteBackupToLocalReturns struct {
		result1 error
	}
	copyRemoteBackupToLocalReturnsOnCall map[int]struct {
		result1 error
	}
	CopyLocalBackupToRemoteStub        func(orchestrator.Backup) error
	copyLocalBackupToRemoteMutex       sync.RWMutex
	copyLocalBackupToRemoteArgsForCall []struct {
		arg1 orchestrator.Backup
	}
	copyLocalBackupToRemoteReturns struct {
		result1 error
	}
	copyLocalBackupToRemoteReturnsOnCall map[int]struct {
		result1 error
	}
	CleanupStub        func() error
	cleanupMutex       sync.RWMutex
	cleanupArgsForCall []struct{}
	cleanupReturns     struct {
		result1 error
	}
	cleanupReturnsOnCall map[int]struct {
		result1 error
	}
	CleanupPreviousStub        func() error
	cleanupPreviousMutex       sync.RWMutex
	cleanupPreviousArgsForCall []struct{}
	cleanupPreviousReturns     struct {
		result1 error
	}
	cleanupPreviousReturnsOnCall map[int]struct {
		result1 error
	}
	InstancesStub        func() []orchestrator.Instance
	instancesMutex       sync.RWMutex
	instancesArgsForCall []struct{}
	instancesReturns     struct {
		result1 []orchestrator.Instance
	}
	instancesReturnsOnCall map[int]struct {
		result1 []orchestrator.Instance
	}
	CustomArtifactNamesMatchStub        func() error
	customArtifactNamesMatchMutex       sync.RWMutex
	customArtifactNamesMatchArgsForCall []struct{}
	customArtifactNamesMatchReturns     struct {
		result1 error
	}
	customArtifactNamesMatchReturnsOnCall map[int]struct {
		result1 error
	}
	PostRestoreUnlockStub        func() error
	postRestoreUnlockMutex       sync.RWMutex
	postRestoreUnlockArgsForCall []struct{}
	postRestoreUnlockReturns     struct {
		result1 error
	}
	postRestoreUnlockReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDeployment) IsBackupable() bool {
	fake.isBackupableMutex.Lock()
	ret, specificReturn := fake.isBackupableReturnsOnCall[len(fake.isBackupableArgsForCall)]
	fake.isBackupableArgsForCall = append(fake.isBackupableArgsForCall, struct{}{})
	fake.recordInvocation("IsBackupable", []interface{}{})
	fake.isBackupableMutex.Unlock()
	if fake.IsBackupableStub != nil {
		return fake.IsBackupableStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isBackupableReturns.result1
}

func (fake *FakeDeployment) IsBackupableCallCount() int {
	fake.isBackupableMutex.RLock()
	defer fake.isBackupableMutex.RUnlock()
	return len(fake.isBackupableArgsForCall)
}

func (fake *FakeDeployment) IsBackupableReturns(result1 bool) {
	fake.IsBackupableStub = nil
	fake.isBackupableReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDeployment) IsBackupableReturnsOnCall(i int, result1 bool) {
	fake.IsBackupableStub = nil
	if fake.isBackupableReturnsOnCall == nil {
		fake.isBackupableReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isBackupableReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDeployment) HasUniqueCustomArtifactNames() bool {
	fake.hasUniqueCustomArtifactNamesMutex.Lock()
	ret, specificReturn := fake.hasUniqueCustomArtifactNamesReturnsOnCall[len(fake.hasUniqueCustomArtifactNamesArgsForCall)]
	fake.hasUniqueCustomArtifactNamesArgsForCall = append(fake.hasUniqueCustomArtifactNamesArgsForCall, struct{}{})
	fake.recordInvocation("HasUniqueCustomArtifactNames", []interface{}{})
	fake.hasUniqueCustomArtifactNamesMutex.Unlock()
	if fake.HasUniqueCustomArtifactNamesStub != nil {
		return fake.HasUniqueCustomArtifactNamesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.hasUniqueCustomArtifactNamesReturns.result1
}

func (fake *FakeDeployment) HasUniqueCustomArtifactNamesCallCount() int {
	fake.hasUniqueCustomArtifactNamesMutex.RLock()
	defer fake.hasUniqueCustomArtifactNamesMutex.RUnlock()
	return len(fake.hasUniqueCustomArtifactNamesArgsForCall)
}

func (fake *FakeDeployment) HasUniqueCustomArtifactNamesReturns(result1 bool) {
	fake.HasUniqueCustomArtifactNamesStub = nil
	fake.hasUniqueCustomArtifactNamesReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDeployment) HasUniqueCustomArtifactNamesReturnsOnCall(i int, result1 bool) {
	fake.HasUniqueCustomArtifactNamesStub = nil
	if fake.hasUniqueCustomArtifactNamesReturnsOnCall == nil {
		fake.hasUniqueCustomArtifactNamesReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasUniqueCustomArtifactNamesReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDeployment) CheckArtifactDir() error {
	fake.checkArtifactDirMutex.Lock()
	ret, specificReturn := fake.checkArtifactDirReturnsOnCall[len(fake.checkArtifactDirArgsForCall)]
	fake.checkArtifactDirArgsForCall = append(fake.checkArtifactDirArgsForCall, struct{}{})
	fake.recordInvocation("CheckArtifactDir", []interface{}{})
	fake.checkArtifactDirMutex.Unlock()
	if fake.CheckArtifactDirStub != nil {
		return fake.CheckArtifactDirStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.checkArtifactDirReturns.result1
}

func (fake *FakeDeployment) CheckArtifactDirCallCount() int {
	fake.checkArtifactDirMutex.RLock()
	defer fake.checkArtifactDirMutex.RUnlock()
	return len(fake.checkArtifactDirArgsForCall)
}

func (fake *FakeDeployment) CheckArtifactDirReturns(result1 error) {
	fake.CheckArtifactDirStub = nil
	fake.checkArtifactDirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CheckArtifactDirReturnsOnCall(i int, result1 error) {
	fake.CheckArtifactDirStub = nil
	if fake.checkArtifactDirReturnsOnCall == nil {
		fake.checkArtifactDirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkArtifactDirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) IsRestorable() bool {
	fake.isRestorableMutex.Lock()
	ret, specificReturn := fake.isRestorableReturnsOnCall[len(fake.isRestorableArgsForCall)]
	fake.isRestorableArgsForCall = append(fake.isRestorableArgsForCall, struct{}{})
	fake.recordInvocation("IsRestorable", []interface{}{})
	fake.isRestorableMutex.Unlock()
	if fake.IsRestorableStub != nil {
		return fake.IsRestorableStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isRestorableReturns.result1
}

func (fake *FakeDeployment) IsRestorableCallCount() int {
	fake.isRestorableMutex.RLock()
	defer fake.isRestorableMutex.RUnlock()
	return len(fake.isRestorableArgsForCall)
}

func (fake *FakeDeployment) IsRestorableReturns(result1 bool) {
	fake.IsRestorableStub = nil
	fake.isRestorableReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDeployment) IsRestorableReturnsOnCall(i int, result1 bool) {
	fake.IsRestorableStub = nil
	if fake.isRestorableReturnsOnCall == nil {
		fake.isRestorableReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isRestorableReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDeployment) PreBackupLock() error {
	fake.preBackupLockMutex.Lock()
	ret, specificReturn := fake.preBackupLockReturnsOnCall[len(fake.preBackupLockArgsForCall)]
	fake.preBackupLockArgsForCall = append(fake.preBackupLockArgsForCall, struct{}{})
	fake.recordInvocation("PreBackupLock", []interface{}{})
	fake.preBackupLockMutex.Unlock()
	if fake.PreBackupLockStub != nil {
		return fake.PreBackupLockStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.preBackupLockReturns.result1
}

func (fake *FakeDeployment) PreBackupLockCallCount() int {
	fake.preBackupLockMutex.RLock()
	defer fake.preBackupLockMutex.RUnlock()
	return len(fake.preBackupLockArgsForCall)
}

func (fake *FakeDeployment) PreBackupLockReturns(result1 error) {
	fake.PreBackupLockStub = nil
	fake.preBackupLockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) PreBackupLockReturnsOnCall(i int, result1 error) {
	fake.PreBackupLockStub = nil
	if fake.preBackupLockReturnsOnCall == nil {
		fake.preBackupLockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.preBackupLockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Backup() error {
	fake.backupMutex.Lock()
	ret, specificReturn := fake.backupReturnsOnCall[len(fake.backupArgsForCall)]
	fake.backupArgsForCall = append(fake.backupArgsForCall, struct{}{})
	fake.recordInvocation("Backup", []interface{}{})
	fake.backupMutex.Unlock()
	if fake.BackupStub != nil {
		return fake.BackupStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.backupReturns.result1
}

func (fake *FakeDeployment) BackupCallCount() int {
	fake.backupMutex.RLock()
	defer fake.backupMutex.RUnlock()
	return len(fake.backupArgsForCall)
}

func (fake *FakeDeployment) BackupReturns(result1 error) {
	fake.BackupStub = nil
	fake.backupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) BackupReturnsOnCall(i int, result1 error) {
	fake.BackupStub = nil
	if fake.backupReturnsOnCall == nil {
		fake.backupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.backupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) PostBackupUnlock() error {
	fake.postBackupUnlockMutex.Lock()
	ret, specificReturn := fake.postBackupUnlockReturnsOnCall[len(fake.postBackupUnlockArgsForCall)]
	fake.postBackupUnlockArgsForCall = append(fake.postBackupUnlockArgsForCall, struct{}{})
	fake.recordInvocation("PostBackupUnlock", []interface{}{})
	fake.postBackupUnlockMutex.Unlock()
	if fake.PostBackupUnlockStub != nil {
		return fake.PostBackupUnlockStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.postBackupUnlockReturns.result1
}

func (fake *FakeDeployment) PostBackupUnlockCallCount() int {
	fake.postBackupUnlockMutex.RLock()
	defer fake.postBackupUnlockMutex.RUnlock()
	return len(fake.postBackupUnlockArgsForCall)
}

func (fake *FakeDeployment) PostBackupUnlockReturns(result1 error) {
	fake.PostBackupUnlockStub = nil
	fake.postBackupUnlockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) PostBackupUnlockReturnsOnCall(i int, result1 error) {
	fake.PostBackupUnlockStub = nil
	if fake.postBackupUnlockReturnsOnCall == nil {
		fake.postBackupUnlockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postBackupUnlockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Restore() error {
	fake.restoreMutex.Lock()
	ret, specificReturn := fake.restoreReturnsOnCall[len(fake.restoreArgsForCall)]
	fake.restoreArgsForCall = append(fake.restoreArgsForCall, struct{}{})
	fake.recordInvocation("Restore", []interface{}{})
	fake.restoreMutex.Unlock()
	if fake.RestoreStub != nil {
		return fake.RestoreStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.restoreReturns.result1
}

func (fake *FakeDeployment) RestoreCallCount() int {
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	return len(fake.restoreArgsForCall)
}

func (fake *FakeDeployment) RestoreReturns(result1 error) {
	fake.RestoreStub = nil
	fake.restoreReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) RestoreReturnsOnCall(i int, result1 error) {
	fake.RestoreStub = nil
	if fake.restoreReturnsOnCall == nil {
		fake.restoreReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.restoreReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CopyRemoteBackupToLocal(arg1 orchestrator.Backup) error {
	fake.copyRemoteBackupToLocalMutex.Lock()
	ret, specificReturn := fake.copyRemoteBackupToLocalReturnsOnCall[len(fake.copyRemoteBackupToLocalArgsForCall)]
	fake.copyRemoteBackupToLocalArgsForCall = append(fake.copyRemoteBackupToLocalArgsForCall, struct {
		arg1 orchestrator.Backup
	}{arg1})
	fake.recordInvocation("CopyRemoteBackupToLocal", []interface{}{arg1})
	fake.copyRemoteBackupToLocalMutex.Unlock()
	if fake.CopyRemoteBackupToLocalStub != nil {
		return fake.CopyRemoteBackupToLocalStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.copyRemoteBackupToLocalReturns.result1
}

func (fake *FakeDeployment) CopyRemoteBackupToLocalCallCount() int {
	fake.copyRemoteBackupToLocalMutex.RLock()
	defer fake.copyRemoteBackupToLocalMutex.RUnlock()
	return len(fake.copyRemoteBackupToLocalArgsForCall)
}

func (fake *FakeDeployment) CopyRemoteBackupToLocalArgsForCall(i int) orchestrator.Backup {
	fake.copyRemoteBackupToLocalMutex.RLock()
	defer fake.copyRemoteBackupToLocalMutex.RUnlock()
	return fake.copyRemoteBackupToLocalArgsForCall[i].arg1
}

func (fake *FakeDeployment) CopyRemoteBackupToLocalReturns(result1 error) {
	fake.CopyRemoteBackupToLocalStub = nil
	fake.copyRemoteBackupToLocalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CopyRemoteBackupToLocalReturnsOnCall(i int, result1 error) {
	fake.CopyRemoteBackupToLocalStub = nil
	if fake.copyRemoteBackupToLocalReturnsOnCall == nil {
		fake.copyRemoteBackupToLocalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.copyRemoteBackupToLocalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CopyLocalBackupToRemote(arg1 orchestrator.Backup) error {
	fake.copyLocalBackupToRemoteMutex.Lock()
	ret, specificReturn := fake.copyLocalBackupToRemoteReturnsOnCall[len(fake.copyLocalBackupToRemoteArgsForCall)]
	fake.copyLocalBackupToRemoteArgsForCall = append(fake.copyLocalBackupToRemoteArgsForCall, struct {
		arg1 orchestrator.Backup
	}{arg1})
	fake.recordInvocation("CopyLocalBackupToRemote", []interface{}{arg1})
	fake.copyLocalBackupToRemoteMutex.Unlock()
	if fake.CopyLocalBackupToRemoteStub != nil {
		return fake.CopyLocalBackupToRemoteStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.copyLocalBackupToRemoteReturns.result1
}

func (fake *FakeDeployment) CopyLocalBackupToRemoteCallCount() int {
	fake.copyLocalBackupToRemoteMutex.RLock()
	defer fake.copyLocalBackupToRemoteMutex.RUnlock()
	return len(fake.copyLocalBackupToRemoteArgsForCall)
}

func (fake *FakeDeployment) CopyLocalBackupToRemoteArgsForCall(i int) orchestrator.Backup {
	fake.copyLocalBackupToRemoteMutex.RLock()
	defer fake.copyLocalBackupToRemoteMutex.RUnlock()
	return fake.copyLocalBackupToRemoteArgsForCall[i].arg1
}

func (fake *FakeDeployment) CopyLocalBackupToRemoteReturns(result1 error) {
	fake.CopyLocalBackupToRemoteStub = nil
	fake.copyLocalBackupToRemoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CopyLocalBackupToRemoteReturnsOnCall(i int, result1 error) {
	fake.CopyLocalBackupToRemoteStub = nil
	if fake.copyLocalBackupToRemoteReturnsOnCall == nil {
		fake.copyLocalBackupToRemoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.copyLocalBackupToRemoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Cleanup() error {
	fake.cleanupMutex.Lock()
	ret, specificReturn := fake.cleanupReturnsOnCall[len(fake.cleanupArgsForCall)]
	fake.cleanupArgsForCall = append(fake.cleanupArgsForCall, struct{}{})
	fake.recordInvocation("Cleanup", []interface{}{})
	fake.cleanupMutex.Unlock()
	if fake.CleanupStub != nil {
		return fake.CleanupStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cleanupReturns.result1
}

func (fake *FakeDeployment) CleanupCallCount() int {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return len(fake.cleanupArgsForCall)
}

func (fake *FakeDeployment) CleanupReturns(result1 error) {
	fake.CleanupStub = nil
	fake.cleanupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CleanupReturnsOnCall(i int, result1 error) {
	fake.CleanupStub = nil
	if fake.cleanupReturnsOnCall == nil {
		fake.cleanupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CleanupPrevious() error {
	fake.cleanupPreviousMutex.Lock()
	ret, specificReturn := fake.cleanupPreviousReturnsOnCall[len(fake.cleanupPreviousArgsForCall)]
	fake.cleanupPreviousArgsForCall = append(fake.cleanupPreviousArgsForCall, struct{}{})
	fake.recordInvocation("CleanupPrevious", []interface{}{})
	fake.cleanupPreviousMutex.Unlock()
	if fake.CleanupPreviousStub != nil {
		return fake.CleanupPreviousStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cleanupPreviousReturns.result1
}

func (fake *FakeDeployment) CleanupPreviousCallCount() int {
	fake.cleanupPreviousMutex.RLock()
	defer fake.cleanupPreviousMutex.RUnlock()
	return len(fake.cleanupPreviousArgsForCall)
}

func (fake *FakeDeployment) CleanupPreviousReturns(result1 error) {
	fake.CleanupPreviousStub = nil
	fake.cleanupPreviousReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CleanupPreviousReturnsOnCall(i int, result1 error) {
	fake.CleanupPreviousStub = nil
	if fake.cleanupPreviousReturnsOnCall == nil {
		fake.cleanupPreviousReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupPreviousReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Instances() []orchestrator.Instance {
	fake.instancesMutex.Lock()
	ret, specificReturn := fake.instancesReturnsOnCall[len(fake.instancesArgsForCall)]
	fake.instancesArgsForCall = append(fake.instancesArgsForCall, struct{}{})
	fake.recordInvocation("Instances", []interface{}{})
	fake.instancesMutex.Unlock()
	if fake.InstancesStub != nil {
		return fake.InstancesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.instancesReturns.result1
}

func (fake *FakeDeployment) InstancesCallCount() int {
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	return len(fake.instancesArgsForCall)
}

func (fake *FakeDeployment) InstancesReturns(result1 []orchestrator.Instance) {
	fake.InstancesStub = nil
	fake.instancesReturns = struct {
		result1 []orchestrator.Instance
	}{result1}
}

func (fake *FakeDeployment) InstancesReturnsOnCall(i int, result1 []orchestrator.Instance) {
	fake.InstancesStub = nil
	if fake.instancesReturnsOnCall == nil {
		fake.instancesReturnsOnCall = make(map[int]struct {
			result1 []orchestrator.Instance
		})
	}
	fake.instancesReturnsOnCall[i] = struct {
		result1 []orchestrator.Instance
	}{result1}
}

func (fake *FakeDeployment) CustomArtifactNamesMatch() error {
	fake.customArtifactNamesMatchMutex.Lock()
	ret, specificReturn := fake.customArtifactNamesMatchReturnsOnCall[len(fake.customArtifactNamesMatchArgsForCall)]
	fake.customArtifactNamesMatchArgsForCall = append(fake.customArtifactNamesMatchArgsForCall, struct{}{})
	fake.recordInvocation("CustomArtifactNamesMatch", []interface{}{})
	fake.customArtifactNamesMatchMutex.Unlock()
	if fake.CustomArtifactNamesMatchStub != nil {
		return fake.CustomArtifactNamesMatchStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.customArtifactNamesMatchReturns.result1
}

func (fake *FakeDeployment) CustomArtifactNamesMatchCallCount() int {
	fake.customArtifactNamesMatchMutex.RLock()
	defer fake.customArtifactNamesMatchMutex.RUnlock()
	return len(fake.customArtifactNamesMatchArgsForCall)
}

func (fake *FakeDeployment) CustomArtifactNamesMatchReturns(result1 error) {
	fake.CustomArtifactNamesMatchStub = nil
	fake.customArtifactNamesMatchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CustomArtifactNamesMatchReturnsOnCall(i int, result1 error) {
	fake.CustomArtifactNamesMatchStub = nil
	if fake.customArtifactNamesMatchReturnsOnCall == nil {
		fake.customArtifactNamesMatchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.customArtifactNamesMatchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) PostRestoreUnlock() error {
	fake.postRestoreUnlockMutex.Lock()
	ret, specificReturn := fake.postRestoreUnlockReturnsOnCall[len(fake.postRestoreUnlockArgsForCall)]
	fake.postRestoreUnlockArgsForCall = append(fake.postRestoreUnlockArgsForCall, struct{}{})
	fake.recordInvocation("PostRestoreUnlock", []interface{}{})
	fake.postRestoreUnlockMutex.Unlock()
	if fake.PostRestoreUnlockStub != nil {
		return fake.PostRestoreUnlockStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.postRestoreUnlockReturns.result1
}

func (fake *FakeDeployment) PostRestoreUnlockCallCount() int {
	fake.postRestoreUnlockMutex.RLock()
	defer fake.postRestoreUnlockMutex.RUnlock()
	return len(fake.postRestoreUnlockArgsForCall)
}

func (fake *FakeDeployment) PostRestoreUnlockReturns(result1 error) {
	fake.PostRestoreUnlockStub = nil
	fake.postRestoreUnlockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) PostRestoreUnlockReturnsOnCall(i int, result1 error) {
	fake.PostRestoreUnlockStub = nil
	if fake.postRestoreUnlockReturnsOnCall == nil {
		fake.postRestoreUnlockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postRestoreUnlockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.isBackupableMutex.RLock()
	defer fake.isBackupableMutex.RUnlock()
	fake.hasUniqueCustomArtifactNamesMutex.RLock()
	defer fake.hasUniqueCustomArtifactNamesMutex.RUnlock()
	fake.checkArtifactDirMutex.RLock()
	defer fake.checkArtifactDirMutex.RUnlock()
	fake.isRestorableMutex.RLock()
	defer fake.isRestorableMutex.RUnlock()
	fake.preBackupLockMutex.RLock()
	defer fake.preBackupLockMutex.RUnlock()
	fake.backupMutex.RLock()
	defer fake.backupMutex.RUnlock()
	fake.postBackupUnlockMutex.RLock()
	defer fake.postBackupUnlockMutex.RUnlock()
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	fake.copyRemoteBackupToLocalMutex.RLock()
	defer fake.copyRemoteBackupToLocalMutex.RUnlock()
	fake.copyLocalBackupToRemoteMutex.RLock()
	defer fake.copyLocalBackupToRemoteMutex.RUnlock()
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	fake.cleanupPreviousMutex.RLock()
	defer fake.cleanupPreviousMutex.RUnlock()
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	fake.customArtifactNamesMatchMutex.RLock()
	defer fake.customArtifactNamesMatchMutex.RUnlock()
	fake.postRestoreUnlockMutex.RLock()
	defer fake.postRestoreUnlockMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDeployment) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ orchestrator.Deployment = new(FakeDeployment)
