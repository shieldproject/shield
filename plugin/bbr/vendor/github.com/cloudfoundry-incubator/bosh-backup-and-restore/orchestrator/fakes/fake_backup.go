// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"io"
	"sync"
	"time"

	"github.com/cloudfoundry-incubator/bosh-backup-and-restore/orchestrator"
)

type FakeBackup struct {
	CreateArtifactStub        func(orchestrator.ArtifactIdentifier) (io.WriteCloser, error)
	createArtifactMutex       sync.RWMutex
	createArtifactArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
	}
	createArtifactReturns struct {
		result1 io.WriteCloser
		result2 error
	}
	createArtifactReturnsOnCall map[int]struct {
		result1 io.WriteCloser
		result2 error
	}
	ReadArtifactStub        func(orchestrator.ArtifactIdentifier) (io.ReadCloser, error)
	readArtifactMutex       sync.RWMutex
	readArtifactArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
	}
	readArtifactReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	readArtifactReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	AddChecksumStub        func(orchestrator.ArtifactIdentifier, orchestrator.BackupChecksum) error
	addChecksumMutex       sync.RWMutex
	addChecksumArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
		arg2 orchestrator.BackupChecksum
	}
	addChecksumReturns struct {
		result1 error
	}
	addChecksumReturnsOnCall map[int]struct {
		result1 error
	}
	CreateMetadataFileWithStartTimeStub        func(time.Time) error
	createMetadataFileWithStartTimeMutex       sync.RWMutex
	createMetadataFileWithStartTimeArgsForCall []struct {
		arg1 time.Time
	}
	createMetadataFileWithStartTimeReturns struct {
		result1 error
	}
	createMetadataFileWithStartTimeReturnsOnCall map[int]struct {
		result1 error
	}
	AddFinishTimeStub        func(time.Time) error
	addFinishTimeMutex       sync.RWMutex
	addFinishTimeArgsForCall []struct {
		arg1 time.Time
	}
	addFinishTimeReturns struct {
		result1 error
	}
	addFinishTimeReturnsOnCall map[int]struct {
		result1 error
	}
	FetchChecksumStub        func(orchestrator.ArtifactIdentifier) (orchestrator.BackupChecksum, error)
	fetchChecksumMutex       sync.RWMutex
	fetchChecksumArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
	}
	fetchChecksumReturns struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	fetchChecksumReturnsOnCall map[int]struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	CalculateChecksumStub        func(orchestrator.ArtifactIdentifier) (orchestrator.BackupChecksum, error)
	calculateChecksumMutex       sync.RWMutex
	calculateChecksumArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
	}
	calculateChecksumReturns struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	calculateChecksumReturnsOnCall map[int]struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	DeploymentMatchesStub        func(string, []orchestrator.Instance) (bool, error)
	deploymentMatchesMutex       sync.RWMutex
	deploymentMatchesArgsForCall []struct {
		arg1 string
		arg2 []orchestrator.Instance
	}
	deploymentMatchesReturns struct {
		result1 bool
		result2 error
	}
	deploymentMatchesReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	SaveManifestStub        func(manifest string) error
	saveManifestMutex       sync.RWMutex
	saveManifestArgsForCall []struct {
		manifest string
	}
	saveManifestReturns struct {
		result1 error
	}
	saveManifestReturnsOnCall map[int]struct {
		result1 error
	}
	ValidStub        func() (bool, error)
	validMutex       sync.RWMutex
	validArgsForCall []struct{}
	validReturns     struct {
		result1 bool
		result2 error
	}
	validReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBackup) CreateArtifact(arg1 orchestrator.ArtifactIdentifier) (io.WriteCloser, error) {
	fake.createArtifactMutex.Lock()
	ret, specificReturn := fake.createArtifactReturnsOnCall[len(fake.createArtifactArgsForCall)]
	fake.createArtifactArgsForCall = append(fake.createArtifactArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
	}{arg1})
	fake.recordInvocation("CreateArtifact", []interface{}{arg1})
	fake.createArtifactMutex.Unlock()
	if fake.CreateArtifactStub != nil {
		return fake.CreateArtifactStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createArtifactReturns.result1, fake.createArtifactReturns.result2
}

func (fake *FakeBackup) CreateArtifactCallCount() int {
	fake.createArtifactMutex.RLock()
	defer fake.createArtifactMutex.RUnlock()
	return len(fake.createArtifactArgsForCall)
}

func (fake *FakeBackup) CreateArtifactArgsForCall(i int) orchestrator.ArtifactIdentifier {
	fake.createArtifactMutex.RLock()
	defer fake.createArtifactMutex.RUnlock()
	return fake.createArtifactArgsForCall[i].arg1
}

func (fake *FakeBackup) CreateArtifactReturns(result1 io.WriteCloser, result2 error) {
	fake.CreateArtifactStub = nil
	fake.createArtifactReturns = struct {
		result1 io.WriteCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) CreateArtifactReturnsOnCall(i int, result1 io.WriteCloser, result2 error) {
	fake.CreateArtifactStub = nil
	if fake.createArtifactReturnsOnCall == nil {
		fake.createArtifactReturnsOnCall = make(map[int]struct {
			result1 io.WriteCloser
			result2 error
		})
	}
	fake.createArtifactReturnsOnCall[i] = struct {
		result1 io.WriteCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) ReadArtifact(arg1 orchestrator.ArtifactIdentifier) (io.ReadCloser, error) {
	fake.readArtifactMutex.Lock()
	ret, specificReturn := fake.readArtifactReturnsOnCall[len(fake.readArtifactArgsForCall)]
	fake.readArtifactArgsForCall = append(fake.readArtifactArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
	}{arg1})
	fake.recordInvocation("ReadArtifact", []interface{}{arg1})
	fake.readArtifactMutex.Unlock()
	if fake.ReadArtifactStub != nil {
		return fake.ReadArtifactStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.readArtifactReturns.result1, fake.readArtifactReturns.result2
}

func (fake *FakeBackup) ReadArtifactCallCount() int {
	fake.readArtifactMutex.RLock()
	defer fake.readArtifactMutex.RUnlock()
	return len(fake.readArtifactArgsForCall)
}

func (fake *FakeBackup) ReadArtifactArgsForCall(i int) orchestrator.ArtifactIdentifier {
	fake.readArtifactMutex.RLock()
	defer fake.readArtifactMutex.RUnlock()
	return fake.readArtifactArgsForCall[i].arg1
}

func (fake *FakeBackup) ReadArtifactReturns(result1 io.ReadCloser, result2 error) {
	fake.ReadArtifactStub = nil
	fake.readArtifactReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) ReadArtifactReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ReadArtifactStub = nil
	if fake.readArtifactReturnsOnCall == nil {
		fake.readArtifactReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.readArtifactReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) AddChecksum(arg1 orchestrator.ArtifactIdentifier, arg2 orchestrator.BackupChecksum) error {
	fake.addChecksumMutex.Lock()
	ret, specificReturn := fake.addChecksumReturnsOnCall[len(fake.addChecksumArgsForCall)]
	fake.addChecksumArgsForCall = append(fake.addChecksumArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
		arg2 orchestrator.BackupChecksum
	}{arg1, arg2})
	fake.recordInvocation("AddChecksum", []interface{}{arg1, arg2})
	fake.addChecksumMutex.Unlock()
	if fake.AddChecksumStub != nil {
		return fake.AddChecksumStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addChecksumReturns.result1
}

func (fake *FakeBackup) AddChecksumCallCount() int {
	fake.addChecksumMutex.RLock()
	defer fake.addChecksumMutex.RUnlock()
	return len(fake.addChecksumArgsForCall)
}

func (fake *FakeBackup) AddChecksumArgsForCall(i int) (orchestrator.ArtifactIdentifier, orchestrator.BackupChecksum) {
	fake.addChecksumMutex.RLock()
	defer fake.addChecksumMutex.RUnlock()
	return fake.addChecksumArgsForCall[i].arg1, fake.addChecksumArgsForCall[i].arg2
}

func (fake *FakeBackup) AddChecksumReturns(result1 error) {
	fake.AddChecksumStub = nil
	fake.addChecksumReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) AddChecksumReturnsOnCall(i int, result1 error) {
	fake.AddChecksumStub = nil
	if fake.addChecksumReturnsOnCall == nil {
		fake.addChecksumReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addChecksumReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) CreateMetadataFileWithStartTime(arg1 time.Time) error {
	fake.createMetadataFileWithStartTimeMutex.Lock()
	ret, specificReturn := fake.createMetadataFileWithStartTimeReturnsOnCall[len(fake.createMetadataFileWithStartTimeArgsForCall)]
	fake.createMetadataFileWithStartTimeArgsForCall = append(fake.createMetadataFileWithStartTimeArgsForCall, struct {
		arg1 time.Time
	}{arg1})
	fake.recordInvocation("CreateMetadataFileWithStartTime", []interface{}{arg1})
	fake.createMetadataFileWithStartTimeMutex.Unlock()
	if fake.CreateMetadataFileWithStartTimeStub != nil {
		return fake.CreateMetadataFileWithStartTimeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createMetadataFileWithStartTimeReturns.result1
}

func (fake *FakeBackup) CreateMetadataFileWithStartTimeCallCount() int {
	fake.createMetadataFileWithStartTimeMutex.RLock()
	defer fake.createMetadataFileWithStartTimeMutex.RUnlock()
	return len(fake.createMetadataFileWithStartTimeArgsForCall)
}

func (fake *FakeBackup) CreateMetadataFileWithStartTimeArgsForCall(i int) time.Time {
	fake.createMetadataFileWithStartTimeMutex.RLock()
	defer fake.createMetadataFileWithStartTimeMutex.RUnlock()
	return fake.createMetadataFileWithStartTimeArgsForCall[i].arg1
}

func (fake *FakeBackup) CreateMetadataFileWithStartTimeReturns(result1 error) {
	fake.CreateMetadataFileWithStartTimeStub = nil
	fake.createMetadataFileWithStartTimeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) CreateMetadataFileWithStartTimeReturnsOnCall(i int, result1 error) {
	fake.CreateMetadataFileWithStartTimeStub = nil
	if fake.createMetadataFileWithStartTimeReturnsOnCall == nil {
		fake.createMetadataFileWithStartTimeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createMetadataFileWithStartTimeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) AddFinishTime(arg1 time.Time) error {
	fake.addFinishTimeMutex.Lock()
	ret, specificReturn := fake.addFinishTimeReturnsOnCall[len(fake.addFinishTimeArgsForCall)]
	fake.addFinishTimeArgsForCall = append(fake.addFinishTimeArgsForCall, struct {
		arg1 time.Time
	}{arg1})
	fake.recordInvocation("AddFinishTime", []interface{}{arg1})
	fake.addFinishTimeMutex.Unlock()
	if fake.AddFinishTimeStub != nil {
		return fake.AddFinishTimeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addFinishTimeReturns.result1
}

func (fake *FakeBackup) AddFinishTimeCallCount() int {
	fake.addFinishTimeMutex.RLock()
	defer fake.addFinishTimeMutex.RUnlock()
	return len(fake.addFinishTimeArgsForCall)
}

func (fake *FakeBackup) AddFinishTimeArgsForCall(i int) time.Time {
	fake.addFinishTimeMutex.RLock()
	defer fake.addFinishTimeMutex.RUnlock()
	return fake.addFinishTimeArgsForCall[i].arg1
}

func (fake *FakeBackup) AddFinishTimeReturns(result1 error) {
	fake.AddFinishTimeStub = nil
	fake.addFinishTimeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) AddFinishTimeReturnsOnCall(i int, result1 error) {
	fake.AddFinishTimeStub = nil
	if fake.addFinishTimeReturnsOnCall == nil {
		fake.addFinishTimeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addFinishTimeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) FetchChecksum(arg1 orchestrator.ArtifactIdentifier) (orchestrator.BackupChecksum, error) {
	fake.fetchChecksumMutex.Lock()
	ret, specificReturn := fake.fetchChecksumReturnsOnCall[len(fake.fetchChecksumArgsForCall)]
	fake.fetchChecksumArgsForCall = append(fake.fetchChecksumArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
	}{arg1})
	fake.recordInvocation("FetchChecksum", []interface{}{arg1})
	fake.fetchChecksumMutex.Unlock()
	if fake.FetchChecksumStub != nil {
		return fake.FetchChecksumStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.fetchChecksumReturns.result1, fake.fetchChecksumReturns.result2
}

func (fake *FakeBackup) FetchChecksumCallCount() int {
	fake.fetchChecksumMutex.RLock()
	defer fake.fetchChecksumMutex.RUnlock()
	return len(fake.fetchChecksumArgsForCall)
}

func (fake *FakeBackup) FetchChecksumArgsForCall(i int) orchestrator.ArtifactIdentifier {
	fake.fetchChecksumMutex.RLock()
	defer fake.fetchChecksumMutex.RUnlock()
	return fake.fetchChecksumArgsForCall[i].arg1
}

func (fake *FakeBackup) FetchChecksumReturns(result1 orchestrator.BackupChecksum, result2 error) {
	fake.FetchChecksumStub = nil
	fake.fetchChecksumReturns = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) FetchChecksumReturnsOnCall(i int, result1 orchestrator.BackupChecksum, result2 error) {
	fake.FetchChecksumStub = nil
	if fake.fetchChecksumReturnsOnCall == nil {
		fake.fetchChecksumReturnsOnCall = make(map[int]struct {
			result1 orchestrator.BackupChecksum
			result2 error
		})
	}
	fake.fetchChecksumReturnsOnCall[i] = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) CalculateChecksum(arg1 orchestrator.ArtifactIdentifier) (orchestrator.BackupChecksum, error) {
	fake.calculateChecksumMutex.Lock()
	ret, specificReturn := fake.calculateChecksumReturnsOnCall[len(fake.calculateChecksumArgsForCall)]
	fake.calculateChecksumArgsForCall = append(fake.calculateChecksumArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
	}{arg1})
	fake.recordInvocation("CalculateChecksum", []interface{}{arg1})
	fake.calculateChecksumMutex.Unlock()
	if fake.CalculateChecksumStub != nil {
		return fake.CalculateChecksumStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.calculateChecksumReturns.result1, fake.calculateChecksumReturns.result2
}

func (fake *FakeBackup) CalculateChecksumCallCount() int {
	fake.calculateChecksumMutex.RLock()
	defer fake.calculateChecksumMutex.RUnlock()
	return len(fake.calculateChecksumArgsForCall)
}

func (fake *FakeBackup) CalculateChecksumArgsForCall(i int) orchestrator.ArtifactIdentifier {
	fake.calculateChecksumMutex.RLock()
	defer fake.calculateChecksumMutex.RUnlock()
	return fake.calculateChecksumArgsForCall[i].arg1
}

func (fake *FakeBackup) CalculateChecksumReturns(result1 orchestrator.BackupChecksum, result2 error) {
	fake.CalculateChecksumStub = nil
	fake.calculateChecksumReturns = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) CalculateChecksumReturnsOnCall(i int, result1 orchestrator.BackupChecksum, result2 error) {
	fake.CalculateChecksumStub = nil
	if fake.calculateChecksumReturnsOnCall == nil {
		fake.calculateChecksumReturnsOnCall = make(map[int]struct {
			result1 orchestrator.BackupChecksum
			result2 error
		})
	}
	fake.calculateChecksumReturnsOnCall[i] = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) DeploymentMatches(arg1 string, arg2 []orchestrator.Instance) (bool, error) {
	var arg2Copy []orchestrator.Instance
	if arg2 != nil {
		arg2Copy = make([]orchestrator.Instance, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.deploymentMatchesMutex.Lock()
	ret, specificReturn := fake.deploymentMatchesReturnsOnCall[len(fake.deploymentMatchesArgsForCall)]
	fake.deploymentMatchesArgsForCall = append(fake.deploymentMatchesArgsForCall, struct {
		arg1 string
		arg2 []orchestrator.Instance
	}{arg1, arg2Copy})
	fake.recordInvocation("DeploymentMatches", []interface{}{arg1, arg2Copy})
	fake.deploymentMatchesMutex.Unlock()
	if fake.DeploymentMatchesStub != nil {
		return fake.DeploymentMatchesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deploymentMatchesReturns.result1, fake.deploymentMatchesReturns.result2
}

func (fake *FakeBackup) DeploymentMatchesCallCount() int {
	fake.deploymentMatchesMutex.RLock()
	defer fake.deploymentMatchesMutex.RUnlock()
	return len(fake.deploymentMatchesArgsForCall)
}

func (fake *FakeBackup) DeploymentMatchesArgsForCall(i int) (string, []orchestrator.Instance) {
	fake.deploymentMatchesMutex.RLock()
	defer fake.deploymentMatchesMutex.RUnlock()
	return fake.deploymentMatchesArgsForCall[i].arg1, fake.deploymentMatchesArgsForCall[i].arg2
}

func (fake *FakeBackup) DeploymentMatchesReturns(result1 bool, result2 error) {
	fake.DeploymentMatchesStub = nil
	fake.deploymentMatchesReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) DeploymentMatchesReturnsOnCall(i int, result1 bool, result2 error) {
	fake.DeploymentMatchesStub = nil
	if fake.deploymentMatchesReturnsOnCall == nil {
		fake.deploymentMatchesReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deploymentMatchesReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) SaveManifest(manifest string) error {
	fake.saveManifestMutex.Lock()
	ret, specificReturn := fake.saveManifestReturnsOnCall[len(fake.saveManifestArgsForCall)]
	fake.saveManifestArgsForCall = append(fake.saveManifestArgsForCall, struct {
		manifest string
	}{manifest})
	fake.recordInvocation("SaveManifest", []interface{}{manifest})
	fake.saveManifestMutex.Unlock()
	if fake.SaveManifestStub != nil {
		return fake.SaveManifestStub(manifest)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveManifestReturns.result1
}

func (fake *FakeBackup) SaveManifestCallCount() int {
	fake.saveManifestMutex.RLock()
	defer fake.saveManifestMutex.RUnlock()
	return len(fake.saveManifestArgsForCall)
}

func (fake *FakeBackup) SaveManifestArgsForCall(i int) string {
	fake.saveManifestMutex.RLock()
	defer fake.saveManifestMutex.RUnlock()
	return fake.saveManifestArgsForCall[i].manifest
}

func (fake *FakeBackup) SaveManifestReturns(result1 error) {
	fake.SaveManifestStub = nil
	fake.saveManifestReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) SaveManifestReturnsOnCall(i int, result1 error) {
	fake.SaveManifestStub = nil
	if fake.saveManifestReturnsOnCall == nil {
		fake.saveManifestReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveManifestReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackup) Valid() (bool, error) {
	fake.validMutex.Lock()
	ret, specificReturn := fake.validReturnsOnCall[len(fake.validArgsForCall)]
	fake.validArgsForCall = append(fake.validArgsForCall, struct{}{})
	fake.recordInvocation("Valid", []interface{}{})
	fake.validMutex.Unlock()
	if fake.ValidStub != nil {
		return fake.ValidStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.validReturns.result1, fake.validReturns.result2
}

func (fake *FakeBackup) ValidCallCount() int {
	fake.validMutex.RLock()
	defer fake.validMutex.RUnlock()
	return len(fake.validArgsForCall)
}

func (fake *FakeBackup) ValidReturns(result1 bool, result2 error) {
	fake.ValidStub = nil
	fake.validReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) ValidReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ValidStub = nil
	if fake.validReturnsOnCall == nil {
		fake.validReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.validReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBackup) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createArtifactMutex.RLock()
	defer fake.createArtifactMutex.RUnlock()
	fake.readArtifactMutex.RLock()
	defer fake.readArtifactMutex.RUnlock()
	fake.addChecksumMutex.RLock()
	defer fake.addChecksumMutex.RUnlock()
	fake.createMetadataFileWithStartTimeMutex.RLock()
	defer fake.createMetadataFileWithStartTimeMutex.RUnlock()
	fake.addFinishTimeMutex.RLock()
	defer fake.addFinishTimeMutex.RUnlock()
	fake.fetchChecksumMutex.RLock()
	defer fake.fetchChecksumMutex.RUnlock()
	fake.calculateChecksumMutex.RLock()
	defer fake.calculateChecksumMutex.RUnlock()
	fake.deploymentMatchesMutex.RLock()
	defer fake.deploymentMatchesMutex.RUnlock()
	fake.saveManifestMutex.RLock()
	defer fake.saveManifestMutex.RUnlock()
	fake.validMutex.RLock()
	defer fake.validMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBackup) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ orchestrator.Backup = new(FakeBackup)
