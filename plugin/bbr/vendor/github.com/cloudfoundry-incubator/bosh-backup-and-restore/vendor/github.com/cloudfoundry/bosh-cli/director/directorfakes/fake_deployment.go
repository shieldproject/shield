// This file was generated by counterfeiter
package directorfakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-cli/director"
)

type FakeDeployment struct {
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct{}
	nameReturns     struct {
		result1 string
	}
	ManifestStub        func() (string, error)
	manifestMutex       sync.RWMutex
	manifestArgsForCall []struct{}
	manifestReturns     struct {
		result1 string
		result2 error
	}
	CloudConfigStub        func() (string, error)
	cloudConfigMutex       sync.RWMutex
	cloudConfigArgsForCall []struct{}
	cloudConfigReturns     struct {
		result1 string
		result2 error
	}
	DiffStub        func([]byte, bool) (director.DeploymentDiff, error)
	diffMutex       sync.RWMutex
	diffArgsForCall []struct {
		arg1 []byte
		arg2 bool
	}
	diffReturns struct {
		result1 director.DeploymentDiff
		result2 error
	}
	ReleasesStub        func() ([]director.Release, error)
	releasesMutex       sync.RWMutex
	releasesArgsForCall []struct{}
	releasesReturns     struct {
		result1 []director.Release
		result2 error
	}
	ExportReleaseStub        func(director.ReleaseSlug, director.OSVersionSlug) (director.ExportReleaseResult, error)
	exportReleaseMutex       sync.RWMutex
	exportReleaseArgsForCall []struct {
		arg1 director.ReleaseSlug
		arg2 director.OSVersionSlug
	}
	exportReleaseReturns struct {
		result1 director.ExportReleaseResult
		result2 error
	}
	TeamsStub        func() ([]string, error)
	teamsMutex       sync.RWMutex
	teamsArgsForCall []struct{}
	teamsReturns     struct {
		result1 []string
		result2 error
	}
	StemcellsStub        func() ([]director.Stemcell, error)
	stemcellsMutex       sync.RWMutex
	stemcellsArgsForCall []struct{}
	stemcellsReturns     struct {
		result1 []director.Stemcell
		result2 error
	}
	VMInfosStub        func() ([]director.VMInfo, error)
	vMInfosMutex       sync.RWMutex
	vMInfosArgsForCall []struct{}
	vMInfosReturns     struct {
		result1 []director.VMInfo
		result2 error
	}
	InstancesStub        func() ([]director.Instance, error)
	instancesMutex       sync.RWMutex
	instancesArgsForCall []struct{}
	instancesReturns     struct {
		result1 []director.Instance
		result2 error
	}
	InstanceInfosStub        func() ([]director.VMInfo, error)
	instanceInfosMutex       sync.RWMutex
	instanceInfosArgsForCall []struct{}
	instanceInfosReturns     struct {
		result1 []director.VMInfo
		result2 error
	}
	ErrandsStub        func() ([]director.Errand, error)
	errandsMutex       sync.RWMutex
	errandsArgsForCall []struct{}
	errandsReturns     struct {
		result1 []director.Errand
		result2 error
	}
	RunErrandStub        func(string, bool, bool) ([]director.ErrandResult, error)
	runErrandMutex       sync.RWMutex
	runErrandArgsForCall []struct {
		arg1 string
		arg2 bool
		arg3 bool
	}
	runErrandReturns struct {
		result1 []director.ErrandResult
		result2 error
	}
	ScanForProblemsStub        func() ([]director.Problem, error)
	scanForProblemsMutex       sync.RWMutex
	scanForProblemsArgsForCall []struct{}
	scanForProblemsReturns     struct {
		result1 []director.Problem
		result2 error
	}
	ResolveProblemsStub        func([]director.ProblemAnswer) error
	resolveProblemsMutex       sync.RWMutex
	resolveProblemsArgsForCall []struct {
		arg1 []director.ProblemAnswer
	}
	resolveProblemsReturns struct {
		result1 error
	}
	SnapshotsStub        func() ([]director.Snapshot, error)
	snapshotsMutex       sync.RWMutex
	snapshotsArgsForCall []struct{}
	snapshotsReturns     struct {
		result1 []director.Snapshot
		result2 error
	}
	TakeSnapshotsStub        func() error
	takeSnapshotsMutex       sync.RWMutex
	takeSnapshotsArgsForCall []struct{}
	takeSnapshotsReturns     struct {
		result1 error
	}
	DeleteSnapshotStub        func(string) error
	deleteSnapshotMutex       sync.RWMutex
	deleteSnapshotArgsForCall []struct {
		arg1 string
	}
	deleteSnapshotReturns struct {
		result1 error
	}
	DeleteSnapshotsStub        func() error
	deleteSnapshotsMutex       sync.RWMutex
	deleteSnapshotsArgsForCall []struct{}
	deleteSnapshotsReturns     struct {
		result1 error
	}
	DeleteVMStub        func(string) error
	deleteVMMutex       sync.RWMutex
	deleteVMArgsForCall []struct {
		arg1 string
	}
	deleteVMReturns struct {
		result1 error
	}
	VariablesStub        func() ([]director.VariableResult, error)
	variablesMutex       sync.RWMutex
	variablesArgsForCall []struct{}
	variablesReturns     struct {
		result1 []director.VariableResult
		result2 error
	}
	StartStub        func(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.StartOpts) error
	startMutex       sync.RWMutex
	startArgsForCall []struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.StartOpts
	}
	startReturns struct {
		result1 error
	}
	StopStub        func(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.StopOpts) error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.StopOpts
	}
	stopReturns struct {
		result1 error
	}
	RestartStub        func(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.RestartOpts) error
	restartMutex       sync.RWMutex
	restartArgsForCall []struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.RestartOpts
	}
	restartReturns struct {
		result1 error
	}
	RecreateStub        func(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.RecreateOpts) error
	recreateMutex       sync.RWMutex
	recreateArgsForCall []struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.RecreateOpts
	}
	recreateReturns struct {
		result1 error
	}
	SetUpSSHStub        func(director.AllOrInstanceGroupOrInstanceSlug, director.SSHOpts) (director.SSHResult, error)
	setUpSSHMutex       sync.RWMutex
	setUpSSHArgsForCall []struct {
		arg1 director.AllOrInstanceGroupOrInstanceSlug
		arg2 director.SSHOpts
	}
	setUpSSHReturns struct {
		result1 director.SSHResult
		result2 error
	}
	CleanUpSSHStub        func(director.AllOrInstanceGroupOrInstanceSlug, director.SSHOpts) error
	cleanUpSSHMutex       sync.RWMutex
	cleanUpSSHArgsForCall []struct {
		arg1 director.AllOrInstanceGroupOrInstanceSlug
		arg2 director.SSHOpts
	}
	cleanUpSSHReturns struct {
		result1 error
	}
	FetchLogsStub        func(director.AllOrInstanceGroupOrInstanceSlug, []string, bool) (director.LogsResult, error)
	fetchLogsMutex       sync.RWMutex
	fetchLogsArgsForCall []struct {
		arg1 director.AllOrInstanceGroupOrInstanceSlug
		arg2 []string
		arg3 bool
	}
	fetchLogsReturns struct {
		result1 director.LogsResult
		result2 error
	}
	TakeSnapshotStub        func(director.InstanceSlug) error
	takeSnapshotMutex       sync.RWMutex
	takeSnapshotArgsForCall []struct {
		arg1 director.InstanceSlug
	}
	takeSnapshotReturns struct {
		result1 error
	}
	IgnoreStub        func(director.InstanceSlug, bool) error
	ignoreMutex       sync.RWMutex
	ignoreArgsForCall []struct {
		arg1 director.InstanceSlug
		arg2 bool
	}
	ignoreReturns struct {
		result1 error
	}
	EnableResurrectionStub        func(director.InstanceSlug, bool) error
	enableResurrectionMutex       sync.RWMutex
	enableResurrectionArgsForCall []struct {
		arg1 director.InstanceSlug
		arg2 bool
	}
	enableResurrectionReturns struct {
		result1 error
	}
	UpdateStub        func(manifest []byte, opts director.UpdateOpts) error
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		manifest []byte
		opts     director.UpdateOpts
	}
	updateReturns struct {
		result1 error
	}
	DeleteStub        func(force bool) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		force bool
	}
	deleteReturns struct {
		result1 error
	}
	AttachDiskStub        func(slug director.InstanceSlug, diskCID string) error
	attachDiskMutex       sync.RWMutex
	attachDiskArgsForCall []struct {
		slug    director.InstanceSlug
		diskCID string
	}
	attachDiskReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDeployment) Name() string {
	fake.nameMutex.Lock()
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct{}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	} else {
		return fake.nameReturns.result1
	}
}

func (fake *FakeDeployment) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeDeployment) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeDeployment) Manifest() (string, error) {
	fake.manifestMutex.Lock()
	fake.manifestArgsForCall = append(fake.manifestArgsForCall, struct{}{})
	fake.recordInvocation("Manifest", []interface{}{})
	fake.manifestMutex.Unlock()
	if fake.ManifestStub != nil {
		return fake.ManifestStub()
	} else {
		return fake.manifestReturns.result1, fake.manifestReturns.result2
	}
}

func (fake *FakeDeployment) ManifestCallCount() int {
	fake.manifestMutex.RLock()
	defer fake.manifestMutex.RUnlock()
	return len(fake.manifestArgsForCall)
}

func (fake *FakeDeployment) ManifestReturns(result1 string, result2 error) {
	fake.ManifestStub = nil
	fake.manifestReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) CloudConfig() (string, error) {
	fake.cloudConfigMutex.Lock()
	fake.cloudConfigArgsForCall = append(fake.cloudConfigArgsForCall, struct{}{})
	fake.recordInvocation("CloudConfig", []interface{}{})
	fake.cloudConfigMutex.Unlock()
	if fake.CloudConfigStub != nil {
		return fake.CloudConfigStub()
	} else {
		return fake.cloudConfigReturns.result1, fake.cloudConfigReturns.result2
	}
}

func (fake *FakeDeployment) CloudConfigCallCount() int {
	fake.cloudConfigMutex.RLock()
	defer fake.cloudConfigMutex.RUnlock()
	return len(fake.cloudConfigArgsForCall)
}

func (fake *FakeDeployment) CloudConfigReturns(result1 string, result2 error) {
	fake.CloudConfigStub = nil
	fake.cloudConfigReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Diff(arg1 []byte, arg2 bool) (director.DeploymentDiff, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.diffMutex.Lock()
	fake.diffArgsForCall = append(fake.diffArgsForCall, struct {
		arg1 []byte
		arg2 bool
	}{arg1Copy, arg2})
	fake.recordInvocation("Diff", []interface{}{arg1Copy, arg2})
	fake.diffMutex.Unlock()
	if fake.DiffStub != nil {
		return fake.DiffStub(arg1, arg2)
	} else {
		return fake.diffReturns.result1, fake.diffReturns.result2
	}
}

func (fake *FakeDeployment) DiffCallCount() int {
	fake.diffMutex.RLock()
	defer fake.diffMutex.RUnlock()
	return len(fake.diffArgsForCall)
}

func (fake *FakeDeployment) DiffArgsForCall(i int) ([]byte, bool) {
	fake.diffMutex.RLock()
	defer fake.diffMutex.RUnlock()
	return fake.diffArgsForCall[i].arg1, fake.diffArgsForCall[i].arg2
}

func (fake *FakeDeployment) DiffReturns(result1 director.DeploymentDiff, result2 error) {
	fake.DiffStub = nil
	fake.diffReturns = struct {
		result1 director.DeploymentDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Releases() ([]director.Release, error) {
	fake.releasesMutex.Lock()
	fake.releasesArgsForCall = append(fake.releasesArgsForCall, struct{}{})
	fake.recordInvocation("Releases", []interface{}{})
	fake.releasesMutex.Unlock()
	if fake.ReleasesStub != nil {
		return fake.ReleasesStub()
	} else {
		return fake.releasesReturns.result1, fake.releasesReturns.result2
	}
}

func (fake *FakeDeployment) ReleasesCallCount() int {
	fake.releasesMutex.RLock()
	defer fake.releasesMutex.RUnlock()
	return len(fake.releasesArgsForCall)
}

func (fake *FakeDeployment) ReleasesReturns(result1 []director.Release, result2 error) {
	fake.ReleasesStub = nil
	fake.releasesReturns = struct {
		result1 []director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) ExportRelease(arg1 director.ReleaseSlug, arg2 director.OSVersionSlug) (director.ExportReleaseResult, error) {
	fake.exportReleaseMutex.Lock()
	fake.exportReleaseArgsForCall = append(fake.exportReleaseArgsForCall, struct {
		arg1 director.ReleaseSlug
		arg2 director.OSVersionSlug
	}{arg1, arg2})
	fake.recordInvocation("ExportRelease", []interface{}{arg1, arg2})
	fake.exportReleaseMutex.Unlock()
	if fake.ExportReleaseStub != nil {
		return fake.ExportReleaseStub(arg1, arg2)
	} else {
		return fake.exportReleaseReturns.result1, fake.exportReleaseReturns.result2
	}
}

func (fake *FakeDeployment) ExportReleaseCallCount() int {
	fake.exportReleaseMutex.RLock()
	defer fake.exportReleaseMutex.RUnlock()
	return len(fake.exportReleaseArgsForCall)
}

func (fake *FakeDeployment) ExportReleaseArgsForCall(i int) (director.ReleaseSlug, director.OSVersionSlug) {
	fake.exportReleaseMutex.RLock()
	defer fake.exportReleaseMutex.RUnlock()
	return fake.exportReleaseArgsForCall[i].arg1, fake.exportReleaseArgsForCall[i].arg2
}

func (fake *FakeDeployment) ExportReleaseReturns(result1 director.ExportReleaseResult, result2 error) {
	fake.ExportReleaseStub = nil
	fake.exportReleaseReturns = struct {
		result1 director.ExportReleaseResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Teams() ([]string, error) {
	fake.teamsMutex.Lock()
	fake.teamsArgsForCall = append(fake.teamsArgsForCall, struct{}{})
	fake.recordInvocation("Teams", []interface{}{})
	fake.teamsMutex.Unlock()
	if fake.TeamsStub != nil {
		return fake.TeamsStub()
	} else {
		return fake.teamsReturns.result1, fake.teamsReturns.result2
	}
}

func (fake *FakeDeployment) TeamsCallCount() int {
	fake.teamsMutex.RLock()
	defer fake.teamsMutex.RUnlock()
	return len(fake.teamsArgsForCall)
}

func (fake *FakeDeployment) TeamsReturns(result1 []string, result2 error) {
	fake.TeamsStub = nil
	fake.teamsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Stemcells() ([]director.Stemcell, error) {
	fake.stemcellsMutex.Lock()
	fake.stemcellsArgsForCall = append(fake.stemcellsArgsForCall, struct{}{})
	fake.recordInvocation("Stemcells", []interface{}{})
	fake.stemcellsMutex.Unlock()
	if fake.StemcellsStub != nil {
		return fake.StemcellsStub()
	} else {
		return fake.stemcellsReturns.result1, fake.stemcellsReturns.result2
	}
}

func (fake *FakeDeployment) StemcellsCallCount() int {
	fake.stemcellsMutex.RLock()
	defer fake.stemcellsMutex.RUnlock()
	return len(fake.stemcellsArgsForCall)
}

func (fake *FakeDeployment) StemcellsReturns(result1 []director.Stemcell, result2 error) {
	fake.StemcellsStub = nil
	fake.stemcellsReturns = struct {
		result1 []director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) VMInfos() ([]director.VMInfo, error) {
	fake.vMInfosMutex.Lock()
	fake.vMInfosArgsForCall = append(fake.vMInfosArgsForCall, struct{}{})
	fake.recordInvocation("VMInfos", []interface{}{})
	fake.vMInfosMutex.Unlock()
	if fake.VMInfosStub != nil {
		return fake.VMInfosStub()
	} else {
		return fake.vMInfosReturns.result1, fake.vMInfosReturns.result2
	}
}

func (fake *FakeDeployment) VMInfosCallCount() int {
	fake.vMInfosMutex.RLock()
	defer fake.vMInfosMutex.RUnlock()
	return len(fake.vMInfosArgsForCall)
}

func (fake *FakeDeployment) VMInfosReturns(result1 []director.VMInfo, result2 error) {
	fake.VMInfosStub = nil
	fake.vMInfosReturns = struct {
		result1 []director.VMInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Instances() ([]director.Instance, error) {
	fake.instancesMutex.Lock()
	fake.instancesArgsForCall = append(fake.instancesArgsForCall, struct{}{})
	fake.recordInvocation("Instances", []interface{}{})
	fake.instancesMutex.Unlock()
	if fake.InstancesStub != nil {
		return fake.InstancesStub()
	} else {
		return fake.instancesReturns.result1, fake.instancesReturns.result2
	}
}

func (fake *FakeDeployment) InstancesCallCount() int {
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	return len(fake.instancesArgsForCall)
}

func (fake *FakeDeployment) InstancesReturns(result1 []director.Instance, result2 error) {
	fake.InstancesStub = nil
	fake.instancesReturns = struct {
		result1 []director.Instance
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) InstanceInfos() ([]director.VMInfo, error) {
	fake.instanceInfosMutex.Lock()
	fake.instanceInfosArgsForCall = append(fake.instanceInfosArgsForCall, struct{}{})
	fake.recordInvocation("InstanceInfos", []interface{}{})
	fake.instanceInfosMutex.Unlock()
	if fake.InstanceInfosStub != nil {
		return fake.InstanceInfosStub()
	} else {
		return fake.instanceInfosReturns.result1, fake.instanceInfosReturns.result2
	}
}

func (fake *FakeDeployment) InstanceInfosCallCount() int {
	fake.instanceInfosMutex.RLock()
	defer fake.instanceInfosMutex.RUnlock()
	return len(fake.instanceInfosArgsForCall)
}

func (fake *FakeDeployment) InstanceInfosReturns(result1 []director.VMInfo, result2 error) {
	fake.InstanceInfosStub = nil
	fake.instanceInfosReturns = struct {
		result1 []director.VMInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Errands() ([]director.Errand, error) {
	fake.errandsMutex.Lock()
	fake.errandsArgsForCall = append(fake.errandsArgsForCall, struct{}{})
	fake.recordInvocation("Errands", []interface{}{})
	fake.errandsMutex.Unlock()
	if fake.ErrandsStub != nil {
		return fake.ErrandsStub()
	} else {
		return fake.errandsReturns.result1, fake.errandsReturns.result2
	}
}

func (fake *FakeDeployment) ErrandsCallCount() int {
	fake.errandsMutex.RLock()
	defer fake.errandsMutex.RUnlock()
	return len(fake.errandsArgsForCall)
}

func (fake *FakeDeployment) ErrandsReturns(result1 []director.Errand, result2 error) {
	fake.ErrandsStub = nil
	fake.errandsReturns = struct {
		result1 []director.Errand
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) RunErrand(arg1 string, arg2 bool, arg3 bool) ([]director.ErrandResult, error) {
	fake.runErrandMutex.Lock()
	fake.runErrandArgsForCall = append(fake.runErrandArgsForCall, struct {
		arg1 string
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("RunErrand", []interface{}{arg1, arg2, arg3})
	fake.runErrandMutex.Unlock()
	if fake.RunErrandStub != nil {
		return fake.RunErrandStub(arg1, arg2, arg3)
	} else {
		return fake.runErrandReturns.result1, fake.runErrandReturns.result2
	}
}

func (fake *FakeDeployment) RunErrandCallCount() int {
	fake.runErrandMutex.RLock()
	defer fake.runErrandMutex.RUnlock()
	return len(fake.runErrandArgsForCall)
}

func (fake *FakeDeployment) RunErrandArgsForCall(i int) (string, bool, bool) {
	fake.runErrandMutex.RLock()
	defer fake.runErrandMutex.RUnlock()
	return fake.runErrandArgsForCall[i].arg1, fake.runErrandArgsForCall[i].arg2, fake.runErrandArgsForCall[i].arg3
}

func (fake *FakeDeployment) RunErrandReturns(result1 []director.ErrandResult, result2 error) {
	fake.RunErrandStub = nil
	fake.runErrandReturns = struct {
		result1 []director.ErrandResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) ScanForProblems() ([]director.Problem, error) {
	fake.scanForProblemsMutex.Lock()
	fake.scanForProblemsArgsForCall = append(fake.scanForProblemsArgsForCall, struct{}{})
	fake.recordInvocation("ScanForProblems", []interface{}{})
	fake.scanForProblemsMutex.Unlock()
	if fake.ScanForProblemsStub != nil {
		return fake.ScanForProblemsStub()
	} else {
		return fake.scanForProblemsReturns.result1, fake.scanForProblemsReturns.result2
	}
}

func (fake *FakeDeployment) ScanForProblemsCallCount() int {
	fake.scanForProblemsMutex.RLock()
	defer fake.scanForProblemsMutex.RUnlock()
	return len(fake.scanForProblemsArgsForCall)
}

func (fake *FakeDeployment) ScanForProblemsReturns(result1 []director.Problem, result2 error) {
	fake.ScanForProblemsStub = nil
	fake.scanForProblemsReturns = struct {
		result1 []director.Problem
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) ResolveProblems(arg1 []director.ProblemAnswer) error {
	var arg1Copy []director.ProblemAnswer
	if arg1 != nil {
		arg1Copy = make([]director.ProblemAnswer, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.resolveProblemsMutex.Lock()
	fake.resolveProblemsArgsForCall = append(fake.resolveProblemsArgsForCall, struct {
		arg1 []director.ProblemAnswer
	}{arg1Copy})
	fake.recordInvocation("ResolveProblems", []interface{}{arg1Copy})
	fake.resolveProblemsMutex.Unlock()
	if fake.ResolveProblemsStub != nil {
		return fake.ResolveProblemsStub(arg1)
	} else {
		return fake.resolveProblemsReturns.result1
	}
}

func (fake *FakeDeployment) ResolveProblemsCallCount() int {
	fake.resolveProblemsMutex.RLock()
	defer fake.resolveProblemsMutex.RUnlock()
	return len(fake.resolveProblemsArgsForCall)
}

func (fake *FakeDeployment) ResolveProblemsArgsForCall(i int) []director.ProblemAnswer {
	fake.resolveProblemsMutex.RLock()
	defer fake.resolveProblemsMutex.RUnlock()
	return fake.resolveProblemsArgsForCall[i].arg1
}

func (fake *FakeDeployment) ResolveProblemsReturns(result1 error) {
	fake.ResolveProblemsStub = nil
	fake.resolveProblemsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Snapshots() ([]director.Snapshot, error) {
	fake.snapshotsMutex.Lock()
	fake.snapshotsArgsForCall = append(fake.snapshotsArgsForCall, struct{}{})
	fake.recordInvocation("Snapshots", []interface{}{})
	fake.snapshotsMutex.Unlock()
	if fake.SnapshotsStub != nil {
		return fake.SnapshotsStub()
	} else {
		return fake.snapshotsReturns.result1, fake.snapshotsReturns.result2
	}
}

func (fake *FakeDeployment) SnapshotsCallCount() int {
	fake.snapshotsMutex.RLock()
	defer fake.snapshotsMutex.RUnlock()
	return len(fake.snapshotsArgsForCall)
}

func (fake *FakeDeployment) SnapshotsReturns(result1 []director.Snapshot, result2 error) {
	fake.SnapshotsStub = nil
	fake.snapshotsReturns = struct {
		result1 []director.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) TakeSnapshots() error {
	fake.takeSnapshotsMutex.Lock()
	fake.takeSnapshotsArgsForCall = append(fake.takeSnapshotsArgsForCall, struct{}{})
	fake.recordInvocation("TakeSnapshots", []interface{}{})
	fake.takeSnapshotsMutex.Unlock()
	if fake.TakeSnapshotsStub != nil {
		return fake.TakeSnapshotsStub()
	} else {
		return fake.takeSnapshotsReturns.result1
	}
}

func (fake *FakeDeployment) TakeSnapshotsCallCount() int {
	fake.takeSnapshotsMutex.RLock()
	defer fake.takeSnapshotsMutex.RUnlock()
	return len(fake.takeSnapshotsArgsForCall)
}

func (fake *FakeDeployment) TakeSnapshotsReturns(result1 error) {
	fake.TakeSnapshotsStub = nil
	fake.takeSnapshotsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) DeleteSnapshot(arg1 string) error {
	fake.deleteSnapshotMutex.Lock()
	fake.deleteSnapshotArgsForCall = append(fake.deleteSnapshotArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteSnapshot", []interface{}{arg1})
	fake.deleteSnapshotMutex.Unlock()
	if fake.DeleteSnapshotStub != nil {
		return fake.DeleteSnapshotStub(arg1)
	} else {
		return fake.deleteSnapshotReturns.result1
	}
}

func (fake *FakeDeployment) DeleteSnapshotCallCount() int {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	return len(fake.deleteSnapshotArgsForCall)
}

func (fake *FakeDeployment) DeleteSnapshotArgsForCall(i int) string {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	return fake.deleteSnapshotArgsForCall[i].arg1
}

func (fake *FakeDeployment) DeleteSnapshotReturns(result1 error) {
	fake.DeleteSnapshotStub = nil
	fake.deleteSnapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) DeleteSnapshots() error {
	fake.deleteSnapshotsMutex.Lock()
	fake.deleteSnapshotsArgsForCall = append(fake.deleteSnapshotsArgsForCall, struct{}{})
	fake.recordInvocation("DeleteSnapshots", []interface{}{})
	fake.deleteSnapshotsMutex.Unlock()
	if fake.DeleteSnapshotsStub != nil {
		return fake.DeleteSnapshotsStub()
	} else {
		return fake.deleteSnapshotsReturns.result1
	}
}

func (fake *FakeDeployment) DeleteSnapshotsCallCount() int {
	fake.deleteSnapshotsMutex.RLock()
	defer fake.deleteSnapshotsMutex.RUnlock()
	return len(fake.deleteSnapshotsArgsForCall)
}

func (fake *FakeDeployment) DeleteSnapshotsReturns(result1 error) {
	fake.DeleteSnapshotsStub = nil
	fake.deleteSnapshotsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) DeleteVM(arg1 string) error {
	fake.deleteVMMutex.Lock()
	fake.deleteVMArgsForCall = append(fake.deleteVMArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteVM", []interface{}{arg1})
	fake.deleteVMMutex.Unlock()
	if fake.DeleteVMStub != nil {
		return fake.DeleteVMStub(arg1)
	} else {
		return fake.deleteVMReturns.result1
	}
}

func (fake *FakeDeployment) DeleteVMCallCount() int {
	fake.deleteVMMutex.RLock()
	defer fake.deleteVMMutex.RUnlock()
	return len(fake.deleteVMArgsForCall)
}

func (fake *FakeDeployment) DeleteVMArgsForCall(i int) string {
	fake.deleteVMMutex.RLock()
	defer fake.deleteVMMutex.RUnlock()
	return fake.deleteVMArgsForCall[i].arg1
}

func (fake *FakeDeployment) DeleteVMReturns(result1 error) {
	fake.DeleteVMStub = nil
	fake.deleteVMReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Variables() ([]director.VariableResult, error) {
	fake.variablesMutex.Lock()
	fake.variablesArgsForCall = append(fake.variablesArgsForCall, struct{}{})
	fake.recordInvocation("Variables", []interface{}{})
	fake.variablesMutex.Unlock()
	if fake.VariablesStub != nil {
		return fake.VariablesStub()
	} else {
		return fake.variablesReturns.result1, fake.variablesReturns.result2
	}
}

func (fake *FakeDeployment) VariablesCallCount() int {
	fake.variablesMutex.RLock()
	defer fake.variablesMutex.RUnlock()
	return len(fake.variablesArgsForCall)
}

func (fake *FakeDeployment) VariablesReturns(result1 []director.VariableResult, result2 error) {
	fake.VariablesStub = nil
	fake.variablesReturns = struct {
		result1 []director.VariableResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Start(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.StartOpts) error {
	fake.startMutex.Lock()
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.StartOpts
	}{slug, opts})
	fake.recordInvocation("Start", []interface{}{slug, opts})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub(slug, opts)
	} else {
		return fake.startReturns.result1
	}
}

func (fake *FakeDeployment) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeDeployment) StartArgsForCall(i int) (director.AllOrInstanceGroupOrInstanceSlug, director.StartOpts) {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return fake.startArgsForCall[i].slug, fake.startArgsForCall[i].opts
}

func (fake *FakeDeployment) StartReturns(result1 error) {
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Stop(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.StopOpts) error {
	fake.stopMutex.Lock()
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.StopOpts
	}{slug, opts})
	fake.recordInvocation("Stop", []interface{}{slug, opts})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		return fake.StopStub(slug, opts)
	} else {
		return fake.stopReturns.result1
	}
}

func (fake *FakeDeployment) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeDeployment) StopArgsForCall(i int) (director.AllOrInstanceGroupOrInstanceSlug, director.StopOpts) {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return fake.stopArgsForCall[i].slug, fake.stopArgsForCall[i].opts
}

func (fake *FakeDeployment) StopReturns(result1 error) {
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Restart(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.RestartOpts) error {
	fake.restartMutex.Lock()
	fake.restartArgsForCall = append(fake.restartArgsForCall, struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.RestartOpts
	}{slug, opts})
	fake.recordInvocation("Restart", []interface{}{slug, opts})
	fake.restartMutex.Unlock()
	if fake.RestartStub != nil {
		return fake.RestartStub(slug, opts)
	} else {
		return fake.restartReturns.result1
	}
}

func (fake *FakeDeployment) RestartCallCount() int {
	fake.restartMutex.RLock()
	defer fake.restartMutex.RUnlock()
	return len(fake.restartArgsForCall)
}

func (fake *FakeDeployment) RestartArgsForCall(i int) (director.AllOrInstanceGroupOrInstanceSlug, director.RestartOpts) {
	fake.restartMutex.RLock()
	defer fake.restartMutex.RUnlock()
	return fake.restartArgsForCall[i].slug, fake.restartArgsForCall[i].opts
}

func (fake *FakeDeployment) RestartReturns(result1 error) {
	fake.RestartStub = nil
	fake.restartReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Recreate(slug director.AllOrInstanceGroupOrInstanceSlug, opts director.RecreateOpts) error {
	fake.recreateMutex.Lock()
	fake.recreateArgsForCall = append(fake.recreateArgsForCall, struct {
		slug director.AllOrInstanceGroupOrInstanceSlug
		opts director.RecreateOpts
	}{slug, opts})
	fake.recordInvocation("Recreate", []interface{}{slug, opts})
	fake.recreateMutex.Unlock()
	if fake.RecreateStub != nil {
		return fake.RecreateStub(slug, opts)
	} else {
		return fake.recreateReturns.result1
	}
}

func (fake *FakeDeployment) RecreateCallCount() int {
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	return len(fake.recreateArgsForCall)
}

func (fake *FakeDeployment) RecreateArgsForCall(i int) (director.AllOrInstanceGroupOrInstanceSlug, director.RecreateOpts) {
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	return fake.recreateArgsForCall[i].slug, fake.recreateArgsForCall[i].opts
}

func (fake *FakeDeployment) RecreateReturns(result1 error) {
	fake.RecreateStub = nil
	fake.recreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) SetUpSSH(arg1 director.AllOrInstanceGroupOrInstanceSlug, arg2 director.SSHOpts) (director.SSHResult, error) {
	fake.setUpSSHMutex.Lock()
	fake.setUpSSHArgsForCall = append(fake.setUpSSHArgsForCall, struct {
		arg1 director.AllOrInstanceGroupOrInstanceSlug
		arg2 director.SSHOpts
	}{arg1, arg2})
	fake.recordInvocation("SetUpSSH", []interface{}{arg1, arg2})
	fake.setUpSSHMutex.Unlock()
	if fake.SetUpSSHStub != nil {
		return fake.SetUpSSHStub(arg1, arg2)
	} else {
		return fake.setUpSSHReturns.result1, fake.setUpSSHReturns.result2
	}
}

func (fake *FakeDeployment) SetUpSSHCallCount() int {
	fake.setUpSSHMutex.RLock()
	defer fake.setUpSSHMutex.RUnlock()
	return len(fake.setUpSSHArgsForCall)
}

func (fake *FakeDeployment) SetUpSSHArgsForCall(i int) (director.AllOrInstanceGroupOrInstanceSlug, director.SSHOpts) {
	fake.setUpSSHMutex.RLock()
	defer fake.setUpSSHMutex.RUnlock()
	return fake.setUpSSHArgsForCall[i].arg1, fake.setUpSSHArgsForCall[i].arg2
}

func (fake *FakeDeployment) SetUpSSHReturns(result1 director.SSHResult, result2 error) {
	fake.SetUpSSHStub = nil
	fake.setUpSSHReturns = struct {
		result1 director.SSHResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) CleanUpSSH(arg1 director.AllOrInstanceGroupOrInstanceSlug, arg2 director.SSHOpts) error {
	fake.cleanUpSSHMutex.Lock()
	fake.cleanUpSSHArgsForCall = append(fake.cleanUpSSHArgsForCall, struct {
		arg1 director.AllOrInstanceGroupOrInstanceSlug
		arg2 director.SSHOpts
	}{arg1, arg2})
	fake.recordInvocation("CleanUpSSH", []interface{}{arg1, arg2})
	fake.cleanUpSSHMutex.Unlock()
	if fake.CleanUpSSHStub != nil {
		return fake.CleanUpSSHStub(arg1, arg2)
	} else {
		return fake.cleanUpSSHReturns.result1
	}
}

func (fake *FakeDeployment) CleanUpSSHCallCount() int {
	fake.cleanUpSSHMutex.RLock()
	defer fake.cleanUpSSHMutex.RUnlock()
	return len(fake.cleanUpSSHArgsForCall)
}

func (fake *FakeDeployment) CleanUpSSHArgsForCall(i int) (director.AllOrInstanceGroupOrInstanceSlug, director.SSHOpts) {
	fake.cleanUpSSHMutex.RLock()
	defer fake.cleanUpSSHMutex.RUnlock()
	return fake.cleanUpSSHArgsForCall[i].arg1, fake.cleanUpSSHArgsForCall[i].arg2
}

func (fake *FakeDeployment) CleanUpSSHReturns(result1 error) {
	fake.CleanUpSSHStub = nil
	fake.cleanUpSSHReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) FetchLogs(arg1 director.AllOrInstanceGroupOrInstanceSlug, arg2 []string, arg3 bool) (director.LogsResult, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.fetchLogsMutex.Lock()
	fake.fetchLogsArgsForCall = append(fake.fetchLogsArgsForCall, struct {
		arg1 director.AllOrInstanceGroupOrInstanceSlug
		arg2 []string
		arg3 bool
	}{arg1, arg2Copy, arg3})
	fake.recordInvocation("FetchLogs", []interface{}{arg1, arg2Copy, arg3})
	fake.fetchLogsMutex.Unlock()
	if fake.FetchLogsStub != nil {
		return fake.FetchLogsStub(arg1, arg2, arg3)
	} else {
		return fake.fetchLogsReturns.result1, fake.fetchLogsReturns.result2
	}
}

func (fake *FakeDeployment) FetchLogsCallCount() int {
	fake.fetchLogsMutex.RLock()
	defer fake.fetchLogsMutex.RUnlock()
	return len(fake.fetchLogsArgsForCall)
}

func (fake *FakeDeployment) FetchLogsArgsForCall(i int) (director.AllOrInstanceGroupOrInstanceSlug, []string, bool) {
	fake.fetchLogsMutex.RLock()
	defer fake.fetchLogsMutex.RUnlock()
	return fake.fetchLogsArgsForCall[i].arg1, fake.fetchLogsArgsForCall[i].arg2, fake.fetchLogsArgsForCall[i].arg3
}

func (fake *FakeDeployment) FetchLogsReturns(result1 director.LogsResult, result2 error) {
	fake.FetchLogsStub = nil
	fake.fetchLogsReturns = struct {
		result1 director.LogsResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) TakeSnapshot(arg1 director.InstanceSlug) error {
	fake.takeSnapshotMutex.Lock()
	fake.takeSnapshotArgsForCall = append(fake.takeSnapshotArgsForCall, struct {
		arg1 director.InstanceSlug
	}{arg1})
	fake.recordInvocation("TakeSnapshot", []interface{}{arg1})
	fake.takeSnapshotMutex.Unlock()
	if fake.TakeSnapshotStub != nil {
		return fake.TakeSnapshotStub(arg1)
	} else {
		return fake.takeSnapshotReturns.result1
	}
}

func (fake *FakeDeployment) TakeSnapshotCallCount() int {
	fake.takeSnapshotMutex.RLock()
	defer fake.takeSnapshotMutex.RUnlock()
	return len(fake.takeSnapshotArgsForCall)
}

func (fake *FakeDeployment) TakeSnapshotArgsForCall(i int) director.InstanceSlug {
	fake.takeSnapshotMutex.RLock()
	defer fake.takeSnapshotMutex.RUnlock()
	return fake.takeSnapshotArgsForCall[i].arg1
}

func (fake *FakeDeployment) TakeSnapshotReturns(result1 error) {
	fake.TakeSnapshotStub = nil
	fake.takeSnapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Ignore(arg1 director.InstanceSlug, arg2 bool) error {
	fake.ignoreMutex.Lock()
	fake.ignoreArgsForCall = append(fake.ignoreArgsForCall, struct {
		arg1 director.InstanceSlug
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("Ignore", []interface{}{arg1, arg2})
	fake.ignoreMutex.Unlock()
	if fake.IgnoreStub != nil {
		return fake.IgnoreStub(arg1, arg2)
	} else {
		return fake.ignoreReturns.result1
	}
}

func (fake *FakeDeployment) IgnoreCallCount() int {
	fake.ignoreMutex.RLock()
	defer fake.ignoreMutex.RUnlock()
	return len(fake.ignoreArgsForCall)
}

func (fake *FakeDeployment) IgnoreArgsForCall(i int) (director.InstanceSlug, bool) {
	fake.ignoreMutex.RLock()
	defer fake.ignoreMutex.RUnlock()
	return fake.ignoreArgsForCall[i].arg1, fake.ignoreArgsForCall[i].arg2
}

func (fake *FakeDeployment) IgnoreReturns(result1 error) {
	fake.IgnoreStub = nil
	fake.ignoreReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) EnableResurrection(arg1 director.InstanceSlug, arg2 bool) error {
	fake.enableResurrectionMutex.Lock()
	fake.enableResurrectionArgsForCall = append(fake.enableResurrectionArgsForCall, struct {
		arg1 director.InstanceSlug
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("EnableResurrection", []interface{}{arg1, arg2})
	fake.enableResurrectionMutex.Unlock()
	if fake.EnableResurrectionStub != nil {
		return fake.EnableResurrectionStub(arg1, arg2)
	} else {
		return fake.enableResurrectionReturns.result1
	}
}

func (fake *FakeDeployment) EnableResurrectionCallCount() int {
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	return len(fake.enableResurrectionArgsForCall)
}

func (fake *FakeDeployment) EnableResurrectionArgsForCall(i int) (director.InstanceSlug, bool) {
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	return fake.enableResurrectionArgsForCall[i].arg1, fake.enableResurrectionArgsForCall[i].arg2
}

func (fake *FakeDeployment) EnableResurrectionReturns(result1 error) {
	fake.EnableResurrectionStub = nil
	fake.enableResurrectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Update(manifest []byte, opts director.UpdateOpts) error {
	var manifestCopy []byte
	if manifest != nil {
		manifestCopy = make([]byte, len(manifest))
		copy(manifestCopy, manifest)
	}
	fake.updateMutex.Lock()
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		manifest []byte
		opts     director.UpdateOpts
	}{manifestCopy, opts})
	fake.recordInvocation("Update", []interface{}{manifestCopy, opts})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(manifest, opts)
	} else {
		return fake.updateReturns.result1
	}
}

func (fake *FakeDeployment) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeDeployment) UpdateArgsForCall(i int) ([]byte, director.UpdateOpts) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].manifest, fake.updateArgsForCall[i].opts
}

func (fake *FakeDeployment) UpdateReturns(result1 error) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Delete(force bool) error {
	fake.deleteMutex.Lock()
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		force bool
	}{force})
	fake.recordInvocation("Delete", []interface{}{force})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(force)
	} else {
		return fake.deleteReturns.result1
	}
}

func (fake *FakeDeployment) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeDeployment) DeleteArgsForCall(i int) bool {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].force
}

func (fake *FakeDeployment) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) AttachDisk(slug director.InstanceSlug, diskCID string) error {
	fake.attachDiskMutex.Lock()
	fake.attachDiskArgsForCall = append(fake.attachDiskArgsForCall, struct {
		slug    director.InstanceSlug
		diskCID string
	}{slug, diskCID})
	fake.recordInvocation("AttachDisk", []interface{}{slug, diskCID})
	fake.attachDiskMutex.Unlock()
	if fake.AttachDiskStub != nil {
		return fake.AttachDiskStub(slug, diskCID)
	} else {
		return fake.attachDiskReturns.result1
	}
}

func (fake *FakeDeployment) AttachDiskCallCount() int {
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return len(fake.attachDiskArgsForCall)
}

func (fake *FakeDeployment) AttachDiskArgsForCall(i int) (director.InstanceSlug, string) {
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return fake.attachDiskArgsForCall[i].slug, fake.attachDiskArgsForCall[i].diskCID
}

func (fake *FakeDeployment) AttachDiskReturns(result1 error) {
	fake.AttachDiskStub = nil
	fake.attachDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.manifestMutex.RLock()
	defer fake.manifestMutex.RUnlock()
	fake.cloudConfigMutex.RLock()
	defer fake.cloudConfigMutex.RUnlock()
	fake.diffMutex.RLock()
	defer fake.diffMutex.RUnlock()
	fake.releasesMutex.RLock()
	defer fake.releasesMutex.RUnlock()
	fake.exportReleaseMutex.RLock()
	defer fake.exportReleaseMutex.RUnlock()
	fake.teamsMutex.RLock()
	defer fake.teamsMutex.RUnlock()
	fake.stemcellsMutex.RLock()
	defer fake.stemcellsMutex.RUnlock()
	fake.vMInfosMutex.RLock()
	defer fake.vMInfosMutex.RUnlock()
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	fake.instanceInfosMutex.RLock()
	defer fake.instanceInfosMutex.RUnlock()
	fake.errandsMutex.RLock()
	defer fake.errandsMutex.RUnlock()
	fake.runErrandMutex.RLock()
	defer fake.runErrandMutex.RUnlock()
	fake.scanForProblemsMutex.RLock()
	defer fake.scanForProblemsMutex.RUnlock()
	fake.resolveProblemsMutex.RLock()
	defer fake.resolveProblemsMutex.RUnlock()
	fake.snapshotsMutex.RLock()
	defer fake.snapshotsMutex.RUnlock()
	fake.takeSnapshotsMutex.RLock()
	defer fake.takeSnapshotsMutex.RUnlock()
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	fake.deleteSnapshotsMutex.RLock()
	defer fake.deleteSnapshotsMutex.RUnlock()
	fake.deleteVMMutex.RLock()
	defer fake.deleteVMMutex.RUnlock()
	fake.variablesMutex.RLock()
	defer fake.variablesMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.restartMutex.RLock()
	defer fake.restartMutex.RUnlock()
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	fake.setUpSSHMutex.RLock()
	defer fake.setUpSSHMutex.RUnlock()
	fake.cleanUpSSHMutex.RLock()
	defer fake.cleanUpSSHMutex.RUnlock()
	fake.fetchLogsMutex.RLock()
	defer fake.fetchLogsMutex.RUnlock()
	fake.takeSnapshotMutex.RLock()
	defer fake.takeSnapshotMutex.RUnlock()
	fake.ignoreMutex.RLock()
	defer fake.ignoreMutex.RUnlock()
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeDeployment) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ director.Deployment = new(FakeDeployment)
