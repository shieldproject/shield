// This file was generated by counterfeiter
package directorfakes

import (
	"io"
	"sync"

	"github.com/cloudfoundry/bosh-cli/director"
)

type FakeDirector struct {
	IsAuthenticatedStub        func() (bool, error)
	isAuthenticatedMutex       sync.RWMutex
	isAuthenticatedArgsForCall []struct{}
	isAuthenticatedReturns     struct {
		result1 bool
		result2 error
	}
	WithContextStub        func(id string) director.Director
	withContextMutex       sync.RWMutex
	withContextArgsForCall []struct {
		id string
	}
	withContextReturns struct {
		result1 director.Director
	}
	InfoStub        func() (director.Info, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct{}
	infoReturns     struct {
		result1 director.Info
		result2 error
	}
	LocksStub        func() ([]director.Lock, error)
	locksMutex       sync.RWMutex
	locksArgsForCall []struct{}
	locksReturns     struct {
		result1 []director.Lock
		result2 error
	}
	CurrentTasksStub        func(director.TasksFilter) ([]director.Task, error)
	currentTasksMutex       sync.RWMutex
	currentTasksArgsForCall []struct {
		arg1 director.TasksFilter
	}
	currentTasksReturns struct {
		result1 []director.Task
		result2 error
	}
	RecentTasksStub        func(int, director.TasksFilter) ([]director.Task, error)
	recentTasksMutex       sync.RWMutex
	recentTasksArgsForCall []struct {
		arg1 int
		arg2 director.TasksFilter
	}
	recentTasksReturns struct {
		result1 []director.Task
		result2 error
	}
	FindTaskStub        func(int) (director.Task, error)
	findTaskMutex       sync.RWMutex
	findTaskArgsForCall []struct {
		arg1 int
	}
	findTaskReturns struct {
		result1 director.Task
		result2 error
	}
	FindTasksByContextIdStub        func(string) ([]director.Task, error)
	findTasksByContextIdMutex       sync.RWMutex
	findTasksByContextIdArgsForCall []struct {
		arg1 string
	}
	findTasksByContextIdReturns struct {
		result1 []director.Task
		result2 error
	}
	EventsStub        func(director.EventsFilter) ([]director.Event, error)
	eventsMutex       sync.RWMutex
	eventsArgsForCall []struct {
		arg1 director.EventsFilter
	}
	eventsReturns struct {
		result1 []director.Event
		result2 error
	}
	EventStub        func(string) (director.Event, error)
	eventMutex       sync.RWMutex
	eventArgsForCall []struct {
		arg1 string
	}
	eventReturns struct {
		result1 director.Event
		result2 error
	}
	DeploymentsStub        func() ([]director.Deployment, error)
	deploymentsMutex       sync.RWMutex
	deploymentsArgsForCall []struct{}
	deploymentsReturns     struct {
		result1 []director.Deployment
		result2 error
	}
	FindDeploymentStub        func(string) (director.Deployment, error)
	findDeploymentMutex       sync.RWMutex
	findDeploymentArgsForCall []struct {
		arg1 string
	}
	findDeploymentReturns struct {
		result1 director.Deployment
		result2 error
	}
	ReleasesStub        func() ([]director.Release, error)
	releasesMutex       sync.RWMutex
	releasesArgsForCall []struct{}
	releasesReturns     struct {
		result1 []director.Release
		result2 error
	}
	HasReleaseStub        func(name, version string) (bool, error)
	hasReleaseMutex       sync.RWMutex
	hasReleaseArgsForCall []struct {
		name    string
		version string
	}
	hasReleaseReturns struct {
		result1 bool
		result2 error
	}
	FindReleaseStub        func(director.ReleaseSlug) (director.Release, error)
	findReleaseMutex       sync.RWMutex
	findReleaseArgsForCall []struct {
		arg1 director.ReleaseSlug
	}
	findReleaseReturns struct {
		result1 director.Release
		result2 error
	}
	FindReleaseSeriesStub        func(director.ReleaseSeriesSlug) (director.ReleaseSeries, error)
	findReleaseSeriesMutex       sync.RWMutex
	findReleaseSeriesArgsForCall []struct {
		arg1 director.ReleaseSeriesSlug
	}
	findReleaseSeriesReturns struct {
		result1 director.ReleaseSeries
		result2 error
	}
	UploadReleaseURLStub        func(url, sha1 string, rebase, fix bool) error
	uploadReleaseURLMutex       sync.RWMutex
	uploadReleaseURLArgsForCall []struct {
		url    string
		sha1   string
		rebase bool
		fix    bool
	}
	uploadReleaseURLReturns struct {
		result1 error
	}
	UploadReleaseFileStub        func(file director.UploadFile, rebase, fix bool) error
	uploadReleaseFileMutex       sync.RWMutex
	uploadReleaseFileArgsForCall []struct {
		file   director.UploadFile
		rebase bool
		fix    bool
	}
	uploadReleaseFileReturns struct {
		result1 error
	}
	MatchPackagesStub        func(manifest interface{}, compiled bool) ([]string, error)
	matchPackagesMutex       sync.RWMutex
	matchPackagesArgsForCall []struct {
		manifest interface{}
		compiled bool
	}
	matchPackagesReturns struct {
		result1 []string
		result2 error
	}
	StemcellsStub        func() ([]director.Stemcell, error)
	stemcellsMutex       sync.RWMutex
	stemcellsArgsForCall []struct{}
	stemcellsReturns     struct {
		result1 []director.Stemcell
		result2 error
	}
	HasStemcellStub        func(name, version string) (bool, error)
	hasStemcellMutex       sync.RWMutex
	hasStemcellArgsForCall []struct {
		name    string
		version string
	}
	hasStemcellReturns struct {
		result1 bool
		result2 error
	}
	FindStemcellStub        func(director.StemcellSlug) (director.Stemcell, error)
	findStemcellMutex       sync.RWMutex
	findStemcellArgsForCall []struct {
		arg1 director.StemcellSlug
	}
	findStemcellReturns struct {
		result1 director.Stemcell
		result2 error
	}
	UploadStemcellURLStub        func(url, sha1 string, fix bool) error
	uploadStemcellURLMutex       sync.RWMutex
	uploadStemcellURLArgsForCall []struct {
		url  string
		sha1 string
		fix  bool
	}
	uploadStemcellURLReturns struct {
		result1 error
	}
	UploadStemcellFileStub        func(file director.UploadFile, fix bool) error
	uploadStemcellFileMutex       sync.RWMutex
	uploadStemcellFileArgsForCall []struct {
		file director.UploadFile
		fix  bool
	}
	uploadStemcellFileReturns struct {
		result1 error
	}
	LatestCloudConfigStub        func() (director.CloudConfig, error)
	latestCloudConfigMutex       sync.RWMutex
	latestCloudConfigArgsForCall []struct{}
	latestCloudConfigReturns     struct {
		result1 director.CloudConfig
		result2 error
	}
	UpdateCloudConfigStub        func([]byte) error
	updateCloudConfigMutex       sync.RWMutex
	updateCloudConfigArgsForCall []struct {
		arg1 []byte
	}
	updateCloudConfigReturns struct {
		result1 error
	}
	DiffCloudConfigStub        func(manifest []byte) (director.CloudConfigDiff, error)
	diffCloudConfigMutex       sync.RWMutex
	diffCloudConfigArgsForCall []struct {
		manifest []byte
	}
	diffCloudConfigReturns struct {
		result1 director.CloudConfigDiff
		result2 error
	}
	LatestCPIConfigStub        func() (director.CPIConfig, error)
	latestCPIConfigMutex       sync.RWMutex
	latestCPIConfigArgsForCall []struct{}
	latestCPIConfigReturns     struct {
		result1 director.CPIConfig
		result2 error
	}
	UpdateCPIConfigStub        func([]byte) error
	updateCPIConfigMutex       sync.RWMutex
	updateCPIConfigArgsForCall []struct {
		arg1 []byte
	}
	updateCPIConfigReturns struct {
		result1 error
	}
	LatestRuntimeConfigStub        func(name string) (director.RuntimeConfig, error)
	latestRuntimeConfigMutex       sync.RWMutex
	latestRuntimeConfigArgsForCall []struct {
		name string
	}
	latestRuntimeConfigReturns struct {
		result1 director.RuntimeConfig
		result2 error
	}
	UpdateRuntimeConfigStub        func(name string, manifest []byte) error
	updateRuntimeConfigMutex       sync.RWMutex
	updateRuntimeConfigArgsForCall []struct {
		name     string
		manifest []byte
	}
	updateRuntimeConfigReturns struct {
		result1 error
	}
	FindOrphanDiskStub        func(string) (director.OrphanDisk, error)
	findOrphanDiskMutex       sync.RWMutex
	findOrphanDiskArgsForCall []struct {
		arg1 string
	}
	findOrphanDiskReturns struct {
		result1 director.OrphanDisk
		result2 error
	}
	OrphanDisksStub        func() ([]director.OrphanDisk, error)
	orphanDisksMutex       sync.RWMutex
	orphanDisksArgsForCall []struct{}
	orphanDisksReturns     struct {
		result1 []director.OrphanDisk
		result2 error
	}
	OrphanDiskStub        func(string) error
	orphanDiskMutex       sync.RWMutex
	orphanDiskArgsForCall []struct {
		arg1 string
	}
	orphanDiskReturns struct {
		result1 error
	}
	EnableResurrectionStub        func(bool) error
	enableResurrectionMutex       sync.RWMutex
	enableResurrectionArgsForCall []struct {
		arg1 bool
	}
	enableResurrectionReturns struct {
		result1 error
	}
	CleanUpStub        func(bool) error
	cleanUpMutex       sync.RWMutex
	cleanUpArgsForCall []struct {
		arg1 bool
	}
	cleanUpReturns struct {
		result1 error
	}
	DownloadResourceUncheckedStub        func(blobstoreID string, out io.Writer) error
	downloadResourceUncheckedMutex       sync.RWMutex
	downloadResourceUncheckedArgsForCall []struct {
		blobstoreID string
		out         io.Writer
	}
	downloadResourceUncheckedReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDirector) IsAuthenticated() (bool, error) {
	fake.isAuthenticatedMutex.Lock()
	fake.isAuthenticatedArgsForCall = append(fake.isAuthenticatedArgsForCall, struct{}{})
	fake.recordInvocation("IsAuthenticated", []interface{}{})
	fake.isAuthenticatedMutex.Unlock()
	if fake.IsAuthenticatedStub != nil {
		return fake.IsAuthenticatedStub()
	} else {
		return fake.isAuthenticatedReturns.result1, fake.isAuthenticatedReturns.result2
	}
}

func (fake *FakeDirector) IsAuthenticatedCallCount() int {
	fake.isAuthenticatedMutex.RLock()
	defer fake.isAuthenticatedMutex.RUnlock()
	return len(fake.isAuthenticatedArgsForCall)
}

func (fake *FakeDirector) IsAuthenticatedReturns(result1 bool, result2 error) {
	fake.IsAuthenticatedStub = nil
	fake.isAuthenticatedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) WithContext(id string) director.Director {
	fake.withContextMutex.Lock()
	fake.withContextArgsForCall = append(fake.withContextArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("WithContext", []interface{}{id})
	fake.withContextMutex.Unlock()
	if fake.WithContextStub != nil {
		return fake.WithContextStub(id)
	} else {
		return fake.withContextReturns.result1
	}
}

func (fake *FakeDirector) WithContextCallCount() int {
	fake.withContextMutex.RLock()
	defer fake.withContextMutex.RUnlock()
	return len(fake.withContextArgsForCall)
}

func (fake *FakeDirector) WithContextArgsForCall(i int) string {
	fake.withContextMutex.RLock()
	defer fake.withContextMutex.RUnlock()
	return fake.withContextArgsForCall[i].id
}

func (fake *FakeDirector) WithContextReturns(result1 director.Director) {
	fake.WithContextStub = nil
	fake.withContextReturns = struct {
		result1 director.Director
	}{result1}
}

func (fake *FakeDirector) Info() (director.Info, error) {
	fake.infoMutex.Lock()
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct{}{})
	fake.recordInvocation("Info", []interface{}{})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		return fake.InfoStub()
	} else {
		return fake.infoReturns.result1, fake.infoReturns.result2
	}
}

func (fake *FakeDirector) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeDirector) InfoReturns(result1 director.Info, result2 error) {
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 director.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Locks() ([]director.Lock, error) {
	fake.locksMutex.Lock()
	fake.locksArgsForCall = append(fake.locksArgsForCall, struct{}{})
	fake.recordInvocation("Locks", []interface{}{})
	fake.locksMutex.Unlock()
	if fake.LocksStub != nil {
		return fake.LocksStub()
	} else {
		return fake.locksReturns.result1, fake.locksReturns.result2
	}
}

func (fake *FakeDirector) LocksCallCount() int {
	fake.locksMutex.RLock()
	defer fake.locksMutex.RUnlock()
	return len(fake.locksArgsForCall)
}

func (fake *FakeDirector) LocksReturns(result1 []director.Lock, result2 error) {
	fake.LocksStub = nil
	fake.locksReturns = struct {
		result1 []director.Lock
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) CurrentTasks(arg1 director.TasksFilter) ([]director.Task, error) {
	fake.currentTasksMutex.Lock()
	fake.currentTasksArgsForCall = append(fake.currentTasksArgsForCall, struct {
		arg1 director.TasksFilter
	}{arg1})
	fake.recordInvocation("CurrentTasks", []interface{}{arg1})
	fake.currentTasksMutex.Unlock()
	if fake.CurrentTasksStub != nil {
		return fake.CurrentTasksStub(arg1)
	} else {
		return fake.currentTasksReturns.result1, fake.currentTasksReturns.result2
	}
}

func (fake *FakeDirector) CurrentTasksCallCount() int {
	fake.currentTasksMutex.RLock()
	defer fake.currentTasksMutex.RUnlock()
	return len(fake.currentTasksArgsForCall)
}

func (fake *FakeDirector) CurrentTasksArgsForCall(i int) director.TasksFilter {
	fake.currentTasksMutex.RLock()
	defer fake.currentTasksMutex.RUnlock()
	return fake.currentTasksArgsForCall[i].arg1
}

func (fake *FakeDirector) CurrentTasksReturns(result1 []director.Task, result2 error) {
	fake.CurrentTasksStub = nil
	fake.currentTasksReturns = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) RecentTasks(arg1 int, arg2 director.TasksFilter) ([]director.Task, error) {
	fake.recentTasksMutex.Lock()
	fake.recentTasksArgsForCall = append(fake.recentTasksArgsForCall, struct {
		arg1 int
		arg2 director.TasksFilter
	}{arg1, arg2})
	fake.recordInvocation("RecentTasks", []interface{}{arg1, arg2})
	fake.recentTasksMutex.Unlock()
	if fake.RecentTasksStub != nil {
		return fake.RecentTasksStub(arg1, arg2)
	} else {
		return fake.recentTasksReturns.result1, fake.recentTasksReturns.result2
	}
}

func (fake *FakeDirector) RecentTasksCallCount() int {
	fake.recentTasksMutex.RLock()
	defer fake.recentTasksMutex.RUnlock()
	return len(fake.recentTasksArgsForCall)
}

func (fake *FakeDirector) RecentTasksArgsForCall(i int) (int, director.TasksFilter) {
	fake.recentTasksMutex.RLock()
	defer fake.recentTasksMutex.RUnlock()
	return fake.recentTasksArgsForCall[i].arg1, fake.recentTasksArgsForCall[i].arg2
}

func (fake *FakeDirector) RecentTasksReturns(result1 []director.Task, result2 error) {
	fake.RecentTasksStub = nil
	fake.recentTasksReturns = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindTask(arg1 int) (director.Task, error) {
	fake.findTaskMutex.Lock()
	fake.findTaskArgsForCall = append(fake.findTaskArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("FindTask", []interface{}{arg1})
	fake.findTaskMutex.Unlock()
	if fake.FindTaskStub != nil {
		return fake.FindTaskStub(arg1)
	} else {
		return fake.findTaskReturns.result1, fake.findTaskReturns.result2
	}
}

func (fake *FakeDirector) FindTaskCallCount() int {
	fake.findTaskMutex.RLock()
	defer fake.findTaskMutex.RUnlock()
	return len(fake.findTaskArgsForCall)
}

func (fake *FakeDirector) FindTaskArgsForCall(i int) int {
	fake.findTaskMutex.RLock()
	defer fake.findTaskMutex.RUnlock()
	return fake.findTaskArgsForCall[i].arg1
}

func (fake *FakeDirector) FindTaskReturns(result1 director.Task, result2 error) {
	fake.FindTaskStub = nil
	fake.findTaskReturns = struct {
		result1 director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindTasksByContextId(arg1 string) ([]director.Task, error) {
	fake.findTasksByContextIdMutex.Lock()
	fake.findTasksByContextIdArgsForCall = append(fake.findTasksByContextIdArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindTasksByContextId", []interface{}{arg1})
	fake.findTasksByContextIdMutex.Unlock()
	if fake.FindTasksByContextIdStub != nil {
		return fake.FindTasksByContextIdStub(arg1)
	} else {
		return fake.findTasksByContextIdReturns.result1, fake.findTasksByContextIdReturns.result2
	}
}

func (fake *FakeDirector) FindTasksByContextIdCallCount() int {
	fake.findTasksByContextIdMutex.RLock()
	defer fake.findTasksByContextIdMutex.RUnlock()
	return len(fake.findTasksByContextIdArgsForCall)
}

func (fake *FakeDirector) FindTasksByContextIdArgsForCall(i int) string {
	fake.findTasksByContextIdMutex.RLock()
	defer fake.findTasksByContextIdMutex.RUnlock()
	return fake.findTasksByContextIdArgsForCall[i].arg1
}

func (fake *FakeDirector) FindTasksByContextIdReturns(result1 []director.Task, result2 error) {
	fake.FindTasksByContextIdStub = nil
	fake.findTasksByContextIdReturns = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Events(arg1 director.EventsFilter) ([]director.Event, error) {
	fake.eventsMutex.Lock()
	fake.eventsArgsForCall = append(fake.eventsArgsForCall, struct {
		arg1 director.EventsFilter
	}{arg1})
	fake.recordInvocation("Events", []interface{}{arg1})
	fake.eventsMutex.Unlock()
	if fake.EventsStub != nil {
		return fake.EventsStub(arg1)
	} else {
		return fake.eventsReturns.result1, fake.eventsReturns.result2
	}
}

func (fake *FakeDirector) EventsCallCount() int {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return len(fake.eventsArgsForCall)
}

func (fake *FakeDirector) EventsArgsForCall(i int) director.EventsFilter {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return fake.eventsArgsForCall[i].arg1
}

func (fake *FakeDirector) EventsReturns(result1 []director.Event, result2 error) {
	fake.EventsStub = nil
	fake.eventsReturns = struct {
		result1 []director.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Event(arg1 string) (director.Event, error) {
	fake.eventMutex.Lock()
	fake.eventArgsForCall = append(fake.eventArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Event", []interface{}{arg1})
	fake.eventMutex.Unlock()
	if fake.EventStub != nil {
		return fake.EventStub(arg1)
	} else {
		return fake.eventReturns.result1, fake.eventReturns.result2
	}
}

func (fake *FakeDirector) EventCallCount() int {
	fake.eventMutex.RLock()
	defer fake.eventMutex.RUnlock()
	return len(fake.eventArgsForCall)
}

func (fake *FakeDirector) EventArgsForCall(i int) string {
	fake.eventMutex.RLock()
	defer fake.eventMutex.RUnlock()
	return fake.eventArgsForCall[i].arg1
}

func (fake *FakeDirector) EventReturns(result1 director.Event, result2 error) {
	fake.EventStub = nil
	fake.eventReturns = struct {
		result1 director.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Deployments() ([]director.Deployment, error) {
	fake.deploymentsMutex.Lock()
	fake.deploymentsArgsForCall = append(fake.deploymentsArgsForCall, struct{}{})
	fake.recordInvocation("Deployments", []interface{}{})
	fake.deploymentsMutex.Unlock()
	if fake.DeploymentsStub != nil {
		return fake.DeploymentsStub()
	} else {
		return fake.deploymentsReturns.result1, fake.deploymentsReturns.result2
	}
}

func (fake *FakeDirector) DeploymentsCallCount() int {
	fake.deploymentsMutex.RLock()
	defer fake.deploymentsMutex.RUnlock()
	return len(fake.deploymentsArgsForCall)
}

func (fake *FakeDirector) DeploymentsReturns(result1 []director.Deployment, result2 error) {
	fake.DeploymentsStub = nil
	fake.deploymentsReturns = struct {
		result1 []director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindDeployment(arg1 string) (director.Deployment, error) {
	fake.findDeploymentMutex.Lock()
	fake.findDeploymentArgsForCall = append(fake.findDeploymentArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindDeployment", []interface{}{arg1})
	fake.findDeploymentMutex.Unlock()
	if fake.FindDeploymentStub != nil {
		return fake.FindDeploymentStub(arg1)
	} else {
		return fake.findDeploymentReturns.result1, fake.findDeploymentReturns.result2
	}
}

func (fake *FakeDirector) FindDeploymentCallCount() int {
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	return len(fake.findDeploymentArgsForCall)
}

func (fake *FakeDirector) FindDeploymentArgsForCall(i int) string {
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	return fake.findDeploymentArgsForCall[i].arg1
}

func (fake *FakeDirector) FindDeploymentReturns(result1 director.Deployment, result2 error) {
	fake.FindDeploymentStub = nil
	fake.findDeploymentReturns = struct {
		result1 director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Releases() ([]director.Release, error) {
	fake.releasesMutex.Lock()
	fake.releasesArgsForCall = append(fake.releasesArgsForCall, struct{}{})
	fake.recordInvocation("Releases", []interface{}{})
	fake.releasesMutex.Unlock()
	if fake.ReleasesStub != nil {
		return fake.ReleasesStub()
	} else {
		return fake.releasesReturns.result1, fake.releasesReturns.result2
	}
}

func (fake *FakeDirector) ReleasesCallCount() int {
	fake.releasesMutex.RLock()
	defer fake.releasesMutex.RUnlock()
	return len(fake.releasesArgsForCall)
}

func (fake *FakeDirector) ReleasesReturns(result1 []director.Release, result2 error) {
	fake.ReleasesStub = nil
	fake.releasesReturns = struct {
		result1 []director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) HasRelease(name string, version string) (bool, error) {
	fake.hasReleaseMutex.Lock()
	fake.hasReleaseArgsForCall = append(fake.hasReleaseArgsForCall, struct {
		name    string
		version string
	}{name, version})
	fake.recordInvocation("HasRelease", []interface{}{name, version})
	fake.hasReleaseMutex.Unlock()
	if fake.HasReleaseStub != nil {
		return fake.HasReleaseStub(name, version)
	} else {
		return fake.hasReleaseReturns.result1, fake.hasReleaseReturns.result2
	}
}

func (fake *FakeDirector) HasReleaseCallCount() int {
	fake.hasReleaseMutex.RLock()
	defer fake.hasReleaseMutex.RUnlock()
	return len(fake.hasReleaseArgsForCall)
}

func (fake *FakeDirector) HasReleaseArgsForCall(i int) (string, string) {
	fake.hasReleaseMutex.RLock()
	defer fake.hasReleaseMutex.RUnlock()
	return fake.hasReleaseArgsForCall[i].name, fake.hasReleaseArgsForCall[i].version
}

func (fake *FakeDirector) HasReleaseReturns(result1 bool, result2 error) {
	fake.HasReleaseStub = nil
	fake.hasReleaseReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindRelease(arg1 director.ReleaseSlug) (director.Release, error) {
	fake.findReleaseMutex.Lock()
	fake.findReleaseArgsForCall = append(fake.findReleaseArgsForCall, struct {
		arg1 director.ReleaseSlug
	}{arg1})
	fake.recordInvocation("FindRelease", []interface{}{arg1})
	fake.findReleaseMutex.Unlock()
	if fake.FindReleaseStub != nil {
		return fake.FindReleaseStub(arg1)
	} else {
		return fake.findReleaseReturns.result1, fake.findReleaseReturns.result2
	}
}

func (fake *FakeDirector) FindReleaseCallCount() int {
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	return len(fake.findReleaseArgsForCall)
}

func (fake *FakeDirector) FindReleaseArgsForCall(i int) director.ReleaseSlug {
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	return fake.findReleaseArgsForCall[i].arg1
}

func (fake *FakeDirector) FindReleaseReturns(result1 director.Release, result2 error) {
	fake.FindReleaseStub = nil
	fake.findReleaseReturns = struct {
		result1 director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindReleaseSeries(arg1 director.ReleaseSeriesSlug) (director.ReleaseSeries, error) {
	fake.findReleaseSeriesMutex.Lock()
	fake.findReleaseSeriesArgsForCall = append(fake.findReleaseSeriesArgsForCall, struct {
		arg1 director.ReleaseSeriesSlug
	}{arg1})
	fake.recordInvocation("FindReleaseSeries", []interface{}{arg1})
	fake.findReleaseSeriesMutex.Unlock()
	if fake.FindReleaseSeriesStub != nil {
		return fake.FindReleaseSeriesStub(arg1)
	} else {
		return fake.findReleaseSeriesReturns.result1, fake.findReleaseSeriesReturns.result2
	}
}

func (fake *FakeDirector) FindReleaseSeriesCallCount() int {
	fake.findReleaseSeriesMutex.RLock()
	defer fake.findReleaseSeriesMutex.RUnlock()
	return len(fake.findReleaseSeriesArgsForCall)
}

func (fake *FakeDirector) FindReleaseSeriesArgsForCall(i int) director.ReleaseSeriesSlug {
	fake.findReleaseSeriesMutex.RLock()
	defer fake.findReleaseSeriesMutex.RUnlock()
	return fake.findReleaseSeriesArgsForCall[i].arg1
}

func (fake *FakeDirector) FindReleaseSeriesReturns(result1 director.ReleaseSeries, result2 error) {
	fake.FindReleaseSeriesStub = nil
	fake.findReleaseSeriesReturns = struct {
		result1 director.ReleaseSeries
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UploadReleaseURL(url string, sha1 string, rebase bool, fix bool) error {
	fake.uploadReleaseURLMutex.Lock()
	fake.uploadReleaseURLArgsForCall = append(fake.uploadReleaseURLArgsForCall, struct {
		url    string
		sha1   string
		rebase bool
		fix    bool
	}{url, sha1, rebase, fix})
	fake.recordInvocation("UploadReleaseURL", []interface{}{url, sha1, rebase, fix})
	fake.uploadReleaseURLMutex.Unlock()
	if fake.UploadReleaseURLStub != nil {
		return fake.UploadReleaseURLStub(url, sha1, rebase, fix)
	} else {
		return fake.uploadReleaseURLReturns.result1
	}
}

func (fake *FakeDirector) UploadReleaseURLCallCount() int {
	fake.uploadReleaseURLMutex.RLock()
	defer fake.uploadReleaseURLMutex.RUnlock()
	return len(fake.uploadReleaseURLArgsForCall)
}

func (fake *FakeDirector) UploadReleaseURLArgsForCall(i int) (string, string, bool, bool) {
	fake.uploadReleaseURLMutex.RLock()
	defer fake.uploadReleaseURLMutex.RUnlock()
	return fake.uploadReleaseURLArgsForCall[i].url, fake.uploadReleaseURLArgsForCall[i].sha1, fake.uploadReleaseURLArgsForCall[i].rebase, fake.uploadReleaseURLArgsForCall[i].fix
}

func (fake *FakeDirector) UploadReleaseURLReturns(result1 error) {
	fake.UploadReleaseURLStub = nil
	fake.uploadReleaseURLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadReleaseFile(file director.UploadFile, rebase bool, fix bool) error {
	fake.uploadReleaseFileMutex.Lock()
	fake.uploadReleaseFileArgsForCall = append(fake.uploadReleaseFileArgsForCall, struct {
		file   director.UploadFile
		rebase bool
		fix    bool
	}{file, rebase, fix})
	fake.recordInvocation("UploadReleaseFile", []interface{}{file, rebase, fix})
	fake.uploadReleaseFileMutex.Unlock()
	if fake.UploadReleaseFileStub != nil {
		return fake.UploadReleaseFileStub(file, rebase, fix)
	} else {
		return fake.uploadReleaseFileReturns.result1
	}
}

func (fake *FakeDirector) UploadReleaseFileCallCount() int {
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	return len(fake.uploadReleaseFileArgsForCall)
}

func (fake *FakeDirector) UploadReleaseFileArgsForCall(i int) (director.UploadFile, bool, bool) {
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	return fake.uploadReleaseFileArgsForCall[i].file, fake.uploadReleaseFileArgsForCall[i].rebase, fake.uploadReleaseFileArgsForCall[i].fix
}

func (fake *FakeDirector) UploadReleaseFileReturns(result1 error) {
	fake.UploadReleaseFileStub = nil
	fake.uploadReleaseFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) MatchPackages(manifest interface{}, compiled bool) ([]string, error) {
	fake.matchPackagesMutex.Lock()
	fake.matchPackagesArgsForCall = append(fake.matchPackagesArgsForCall, struct {
		manifest interface{}
		compiled bool
	}{manifest, compiled})
	fake.recordInvocation("MatchPackages", []interface{}{manifest, compiled})
	fake.matchPackagesMutex.Unlock()
	if fake.MatchPackagesStub != nil {
		return fake.MatchPackagesStub(manifest, compiled)
	} else {
		return fake.matchPackagesReturns.result1, fake.matchPackagesReturns.result2
	}
}

func (fake *FakeDirector) MatchPackagesCallCount() int {
	fake.matchPackagesMutex.RLock()
	defer fake.matchPackagesMutex.RUnlock()
	return len(fake.matchPackagesArgsForCall)
}

func (fake *FakeDirector) MatchPackagesArgsForCall(i int) (interface{}, bool) {
	fake.matchPackagesMutex.RLock()
	defer fake.matchPackagesMutex.RUnlock()
	return fake.matchPackagesArgsForCall[i].manifest, fake.matchPackagesArgsForCall[i].compiled
}

func (fake *FakeDirector) MatchPackagesReturns(result1 []string, result2 error) {
	fake.MatchPackagesStub = nil
	fake.matchPackagesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Stemcells() ([]director.Stemcell, error) {
	fake.stemcellsMutex.Lock()
	fake.stemcellsArgsForCall = append(fake.stemcellsArgsForCall, struct{}{})
	fake.recordInvocation("Stemcells", []interface{}{})
	fake.stemcellsMutex.Unlock()
	if fake.StemcellsStub != nil {
		return fake.StemcellsStub()
	} else {
		return fake.stemcellsReturns.result1, fake.stemcellsReturns.result2
	}
}

func (fake *FakeDirector) StemcellsCallCount() int {
	fake.stemcellsMutex.RLock()
	defer fake.stemcellsMutex.RUnlock()
	return len(fake.stemcellsArgsForCall)
}

func (fake *FakeDirector) StemcellsReturns(result1 []director.Stemcell, result2 error) {
	fake.StemcellsStub = nil
	fake.stemcellsReturns = struct {
		result1 []director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) HasStemcell(name string, version string) (bool, error) {
	fake.hasStemcellMutex.Lock()
	fake.hasStemcellArgsForCall = append(fake.hasStemcellArgsForCall, struct {
		name    string
		version string
	}{name, version})
	fake.recordInvocation("HasStemcell", []interface{}{name, version})
	fake.hasStemcellMutex.Unlock()
	if fake.HasStemcellStub != nil {
		return fake.HasStemcellStub(name, version)
	} else {
		return fake.hasStemcellReturns.result1, fake.hasStemcellReturns.result2
	}
}

func (fake *FakeDirector) HasStemcellCallCount() int {
	fake.hasStemcellMutex.RLock()
	defer fake.hasStemcellMutex.RUnlock()
	return len(fake.hasStemcellArgsForCall)
}

func (fake *FakeDirector) HasStemcellArgsForCall(i int) (string, string) {
	fake.hasStemcellMutex.RLock()
	defer fake.hasStemcellMutex.RUnlock()
	return fake.hasStemcellArgsForCall[i].name, fake.hasStemcellArgsForCall[i].version
}

func (fake *FakeDirector) HasStemcellReturns(result1 bool, result2 error) {
	fake.HasStemcellStub = nil
	fake.hasStemcellReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindStemcell(arg1 director.StemcellSlug) (director.Stemcell, error) {
	fake.findStemcellMutex.Lock()
	fake.findStemcellArgsForCall = append(fake.findStemcellArgsForCall, struct {
		arg1 director.StemcellSlug
	}{arg1})
	fake.recordInvocation("FindStemcell", []interface{}{arg1})
	fake.findStemcellMutex.Unlock()
	if fake.FindStemcellStub != nil {
		return fake.FindStemcellStub(arg1)
	} else {
		return fake.findStemcellReturns.result1, fake.findStemcellReturns.result2
	}
}

func (fake *FakeDirector) FindStemcellCallCount() int {
	fake.findStemcellMutex.RLock()
	defer fake.findStemcellMutex.RUnlock()
	return len(fake.findStemcellArgsForCall)
}

func (fake *FakeDirector) FindStemcellArgsForCall(i int) director.StemcellSlug {
	fake.findStemcellMutex.RLock()
	defer fake.findStemcellMutex.RUnlock()
	return fake.findStemcellArgsForCall[i].arg1
}

func (fake *FakeDirector) FindStemcellReturns(result1 director.Stemcell, result2 error) {
	fake.FindStemcellStub = nil
	fake.findStemcellReturns = struct {
		result1 director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UploadStemcellURL(url string, sha1 string, fix bool) error {
	fake.uploadStemcellURLMutex.Lock()
	fake.uploadStemcellURLArgsForCall = append(fake.uploadStemcellURLArgsForCall, struct {
		url  string
		sha1 string
		fix  bool
	}{url, sha1, fix})
	fake.recordInvocation("UploadStemcellURL", []interface{}{url, sha1, fix})
	fake.uploadStemcellURLMutex.Unlock()
	if fake.UploadStemcellURLStub != nil {
		return fake.UploadStemcellURLStub(url, sha1, fix)
	} else {
		return fake.uploadStemcellURLReturns.result1
	}
}

func (fake *FakeDirector) UploadStemcellURLCallCount() int {
	fake.uploadStemcellURLMutex.RLock()
	defer fake.uploadStemcellURLMutex.RUnlock()
	return len(fake.uploadStemcellURLArgsForCall)
}

func (fake *FakeDirector) UploadStemcellURLArgsForCall(i int) (string, string, bool) {
	fake.uploadStemcellURLMutex.RLock()
	defer fake.uploadStemcellURLMutex.RUnlock()
	return fake.uploadStemcellURLArgsForCall[i].url, fake.uploadStemcellURLArgsForCall[i].sha1, fake.uploadStemcellURLArgsForCall[i].fix
}

func (fake *FakeDirector) UploadStemcellURLReturns(result1 error) {
	fake.UploadStemcellURLStub = nil
	fake.uploadStemcellURLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadStemcellFile(file director.UploadFile, fix bool) error {
	fake.uploadStemcellFileMutex.Lock()
	fake.uploadStemcellFileArgsForCall = append(fake.uploadStemcellFileArgsForCall, struct {
		file director.UploadFile
		fix  bool
	}{file, fix})
	fake.recordInvocation("UploadStemcellFile", []interface{}{file, fix})
	fake.uploadStemcellFileMutex.Unlock()
	if fake.UploadStemcellFileStub != nil {
		return fake.UploadStemcellFileStub(file, fix)
	} else {
		return fake.uploadStemcellFileReturns.result1
	}
}

func (fake *FakeDirector) UploadStemcellFileCallCount() int {
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	return len(fake.uploadStemcellFileArgsForCall)
}

func (fake *FakeDirector) UploadStemcellFileArgsForCall(i int) (director.UploadFile, bool) {
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	return fake.uploadStemcellFileArgsForCall[i].file, fake.uploadStemcellFileArgsForCall[i].fix
}

func (fake *FakeDirector) UploadStemcellFileReturns(result1 error) {
	fake.UploadStemcellFileStub = nil
	fake.uploadStemcellFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) LatestCloudConfig() (director.CloudConfig, error) {
	fake.latestCloudConfigMutex.Lock()
	fake.latestCloudConfigArgsForCall = append(fake.latestCloudConfigArgsForCall, struct{}{})
	fake.recordInvocation("LatestCloudConfig", []interface{}{})
	fake.latestCloudConfigMutex.Unlock()
	if fake.LatestCloudConfigStub != nil {
		return fake.LatestCloudConfigStub()
	} else {
		return fake.latestCloudConfigReturns.result1, fake.latestCloudConfigReturns.result2
	}
}

func (fake *FakeDirector) LatestCloudConfigCallCount() int {
	fake.latestCloudConfigMutex.RLock()
	defer fake.latestCloudConfigMutex.RUnlock()
	return len(fake.latestCloudConfigArgsForCall)
}

func (fake *FakeDirector) LatestCloudConfigReturns(result1 director.CloudConfig, result2 error) {
	fake.LatestCloudConfigStub = nil
	fake.latestCloudConfigReturns = struct {
		result1 director.CloudConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UpdateCloudConfig(arg1 []byte) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.updateCloudConfigMutex.Lock()
	fake.updateCloudConfigArgsForCall = append(fake.updateCloudConfigArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	fake.recordInvocation("UpdateCloudConfig", []interface{}{arg1Copy})
	fake.updateCloudConfigMutex.Unlock()
	if fake.UpdateCloudConfigStub != nil {
		return fake.UpdateCloudConfigStub(arg1)
	} else {
		return fake.updateCloudConfigReturns.result1
	}
}

func (fake *FakeDirector) UpdateCloudConfigCallCount() int {
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	return len(fake.updateCloudConfigArgsForCall)
}

func (fake *FakeDirector) UpdateCloudConfigArgsForCall(i int) []byte {
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	return fake.updateCloudConfigArgsForCall[i].arg1
}

func (fake *FakeDirector) UpdateCloudConfigReturns(result1 error) {
	fake.UpdateCloudConfigStub = nil
	fake.updateCloudConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) DiffCloudConfig(manifest []byte) (director.CloudConfigDiff, error) {
	var manifestCopy []byte
	if manifest != nil {
		manifestCopy = make([]byte, len(manifest))
		copy(manifestCopy, manifest)
	}
	fake.diffCloudConfigMutex.Lock()
	fake.diffCloudConfigArgsForCall = append(fake.diffCloudConfigArgsForCall, struct {
		manifest []byte
	}{manifestCopy})
	fake.recordInvocation("DiffCloudConfig", []interface{}{manifestCopy})
	fake.diffCloudConfigMutex.Unlock()
	if fake.DiffCloudConfigStub != nil {
		return fake.DiffCloudConfigStub(manifest)
	} else {
		return fake.diffCloudConfigReturns.result1, fake.diffCloudConfigReturns.result2
	}
}

func (fake *FakeDirector) DiffCloudConfigCallCount() int {
	fake.diffCloudConfigMutex.RLock()
	defer fake.diffCloudConfigMutex.RUnlock()
	return len(fake.diffCloudConfigArgsForCall)
}

func (fake *FakeDirector) DiffCloudConfigArgsForCall(i int) []byte {
	fake.diffCloudConfigMutex.RLock()
	defer fake.diffCloudConfigMutex.RUnlock()
	return fake.diffCloudConfigArgsForCall[i].manifest
}

func (fake *FakeDirector) DiffCloudConfigReturns(result1 director.CloudConfigDiff, result2 error) {
	fake.DiffCloudConfigStub = nil
	fake.diffCloudConfigReturns = struct {
		result1 director.CloudConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestCPIConfig() (director.CPIConfig, error) {
	fake.latestCPIConfigMutex.Lock()
	fake.latestCPIConfigArgsForCall = append(fake.latestCPIConfigArgsForCall, struct{}{})
	fake.recordInvocation("LatestCPIConfig", []interface{}{})
	fake.latestCPIConfigMutex.Unlock()
	if fake.LatestCPIConfigStub != nil {
		return fake.LatestCPIConfigStub()
	} else {
		return fake.latestCPIConfigReturns.result1, fake.latestCPIConfigReturns.result2
	}
}

func (fake *FakeDirector) LatestCPIConfigCallCount() int {
	fake.latestCPIConfigMutex.RLock()
	defer fake.latestCPIConfigMutex.RUnlock()
	return len(fake.latestCPIConfigArgsForCall)
}

func (fake *FakeDirector) LatestCPIConfigReturns(result1 director.CPIConfig, result2 error) {
	fake.LatestCPIConfigStub = nil
	fake.latestCPIConfigReturns = struct {
		result1 director.CPIConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UpdateCPIConfig(arg1 []byte) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.updateCPIConfigMutex.Lock()
	fake.updateCPIConfigArgsForCall = append(fake.updateCPIConfigArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	fake.recordInvocation("UpdateCPIConfig", []interface{}{arg1Copy})
	fake.updateCPIConfigMutex.Unlock()
	if fake.UpdateCPIConfigStub != nil {
		return fake.UpdateCPIConfigStub(arg1)
	} else {
		return fake.updateCPIConfigReturns.result1
	}
}

func (fake *FakeDirector) UpdateCPIConfigCallCount() int {
	fake.updateCPIConfigMutex.RLock()
	defer fake.updateCPIConfigMutex.RUnlock()
	return len(fake.updateCPIConfigArgsForCall)
}

func (fake *FakeDirector) UpdateCPIConfigArgsForCall(i int) []byte {
	fake.updateCPIConfigMutex.RLock()
	defer fake.updateCPIConfigMutex.RUnlock()
	return fake.updateCPIConfigArgsForCall[i].arg1
}

func (fake *FakeDirector) UpdateCPIConfigReturns(result1 error) {
	fake.UpdateCPIConfigStub = nil
	fake.updateCPIConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) LatestRuntimeConfig(name string) (director.RuntimeConfig, error) {
	fake.latestRuntimeConfigMutex.Lock()
	fake.latestRuntimeConfigArgsForCall = append(fake.latestRuntimeConfigArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("LatestRuntimeConfig", []interface{}{name})
	fake.latestRuntimeConfigMutex.Unlock()
	if fake.LatestRuntimeConfigStub != nil {
		return fake.LatestRuntimeConfigStub(name)
	} else {
		return fake.latestRuntimeConfigReturns.result1, fake.latestRuntimeConfigReturns.result2
	}
}

func (fake *FakeDirector) LatestRuntimeConfigCallCount() int {
	fake.latestRuntimeConfigMutex.RLock()
	defer fake.latestRuntimeConfigMutex.RUnlock()
	return len(fake.latestRuntimeConfigArgsForCall)
}

func (fake *FakeDirector) LatestRuntimeConfigArgsForCall(i int) string {
	fake.latestRuntimeConfigMutex.RLock()
	defer fake.latestRuntimeConfigMutex.RUnlock()
	return fake.latestRuntimeConfigArgsForCall[i].name
}

func (fake *FakeDirector) LatestRuntimeConfigReturns(result1 director.RuntimeConfig, result2 error) {
	fake.LatestRuntimeConfigStub = nil
	fake.latestRuntimeConfigReturns = struct {
		result1 director.RuntimeConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UpdateRuntimeConfig(name string, manifest []byte) error {
	var manifestCopy []byte
	if manifest != nil {
		manifestCopy = make([]byte, len(manifest))
		copy(manifestCopy, manifest)
	}
	fake.updateRuntimeConfigMutex.Lock()
	fake.updateRuntimeConfigArgsForCall = append(fake.updateRuntimeConfigArgsForCall, struct {
		name     string
		manifest []byte
	}{name, manifestCopy})
	fake.recordInvocation("UpdateRuntimeConfig", []interface{}{name, manifestCopy})
	fake.updateRuntimeConfigMutex.Unlock()
	if fake.UpdateRuntimeConfigStub != nil {
		return fake.UpdateRuntimeConfigStub(name, manifest)
	} else {
		return fake.updateRuntimeConfigReturns.result1
	}
}

func (fake *FakeDirector) UpdateRuntimeConfigCallCount() int {
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	return len(fake.updateRuntimeConfigArgsForCall)
}

func (fake *FakeDirector) UpdateRuntimeConfigArgsForCall(i int) (string, []byte) {
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	return fake.updateRuntimeConfigArgsForCall[i].name, fake.updateRuntimeConfigArgsForCall[i].manifest
}

func (fake *FakeDirector) UpdateRuntimeConfigReturns(result1 error) {
	fake.UpdateRuntimeConfigStub = nil
	fake.updateRuntimeConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) FindOrphanDisk(arg1 string) (director.OrphanDisk, error) {
	fake.findOrphanDiskMutex.Lock()
	fake.findOrphanDiskArgsForCall = append(fake.findOrphanDiskArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindOrphanDisk", []interface{}{arg1})
	fake.findOrphanDiskMutex.Unlock()
	if fake.FindOrphanDiskStub != nil {
		return fake.FindOrphanDiskStub(arg1)
	} else {
		return fake.findOrphanDiskReturns.result1, fake.findOrphanDiskReturns.result2
	}
}

func (fake *FakeDirector) FindOrphanDiskCallCount() int {
	fake.findOrphanDiskMutex.RLock()
	defer fake.findOrphanDiskMutex.RUnlock()
	return len(fake.findOrphanDiskArgsForCall)
}

func (fake *FakeDirector) FindOrphanDiskArgsForCall(i int) string {
	fake.findOrphanDiskMutex.RLock()
	defer fake.findOrphanDiskMutex.RUnlock()
	return fake.findOrphanDiskArgsForCall[i].arg1
}

func (fake *FakeDirector) FindOrphanDiskReturns(result1 director.OrphanDisk, result2 error) {
	fake.FindOrphanDiskStub = nil
	fake.findOrphanDiskReturns = struct {
		result1 director.OrphanDisk
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanDisks() ([]director.OrphanDisk, error) {
	fake.orphanDisksMutex.Lock()
	fake.orphanDisksArgsForCall = append(fake.orphanDisksArgsForCall, struct{}{})
	fake.recordInvocation("OrphanDisks", []interface{}{})
	fake.orphanDisksMutex.Unlock()
	if fake.OrphanDisksStub != nil {
		return fake.OrphanDisksStub()
	} else {
		return fake.orphanDisksReturns.result1, fake.orphanDisksReturns.result2
	}
}

func (fake *FakeDirector) OrphanDisksCallCount() int {
	fake.orphanDisksMutex.RLock()
	defer fake.orphanDisksMutex.RUnlock()
	return len(fake.orphanDisksArgsForCall)
}

func (fake *FakeDirector) OrphanDisksReturns(result1 []director.OrphanDisk, result2 error) {
	fake.OrphanDisksStub = nil
	fake.orphanDisksReturns = struct {
		result1 []director.OrphanDisk
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanDisk(arg1 string) error {
	fake.orphanDiskMutex.Lock()
	fake.orphanDiskArgsForCall = append(fake.orphanDiskArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("OrphanDisk", []interface{}{arg1})
	fake.orphanDiskMutex.Unlock()
	if fake.OrphanDiskStub != nil {
		return fake.OrphanDiskStub(arg1)
	} else {
		return fake.orphanDiskReturns.result1
	}
}

func (fake *FakeDirector) OrphanDiskCallCount() int {
	fake.orphanDiskMutex.RLock()
	defer fake.orphanDiskMutex.RUnlock()
	return len(fake.orphanDiskArgsForCall)
}

func (fake *FakeDirector) OrphanDiskArgsForCall(i int) string {
	fake.orphanDiskMutex.RLock()
	defer fake.orphanDiskMutex.RUnlock()
	return fake.orphanDiskArgsForCall[i].arg1
}

func (fake *FakeDirector) OrphanDiskReturns(result1 error) {
	fake.OrphanDiskStub = nil
	fake.orphanDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) EnableResurrection(arg1 bool) error {
	fake.enableResurrectionMutex.Lock()
	fake.enableResurrectionArgsForCall = append(fake.enableResurrectionArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("EnableResurrection", []interface{}{arg1})
	fake.enableResurrectionMutex.Unlock()
	if fake.EnableResurrectionStub != nil {
		return fake.EnableResurrectionStub(arg1)
	} else {
		return fake.enableResurrectionReturns.result1
	}
}

func (fake *FakeDirector) EnableResurrectionCallCount() int {
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	return len(fake.enableResurrectionArgsForCall)
}

func (fake *FakeDirector) EnableResurrectionArgsForCall(i int) bool {
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	return fake.enableResurrectionArgsForCall[i].arg1
}

func (fake *FakeDirector) EnableResurrectionReturns(result1 error) {
	fake.EnableResurrectionStub = nil
	fake.enableResurrectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) CleanUp(arg1 bool) error {
	fake.cleanUpMutex.Lock()
	fake.cleanUpArgsForCall = append(fake.cleanUpArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("CleanUp", []interface{}{arg1})
	fake.cleanUpMutex.Unlock()
	if fake.CleanUpStub != nil {
		return fake.CleanUpStub(arg1)
	} else {
		return fake.cleanUpReturns.result1
	}
}

func (fake *FakeDirector) CleanUpCallCount() int {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	return len(fake.cleanUpArgsForCall)
}

func (fake *FakeDirector) CleanUpArgsForCall(i int) bool {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	return fake.cleanUpArgsForCall[i].arg1
}

func (fake *FakeDirector) CleanUpReturns(result1 error) {
	fake.CleanUpStub = nil
	fake.cleanUpReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) DownloadResourceUnchecked(blobstoreID string, out io.Writer) error {
	fake.downloadResourceUncheckedMutex.Lock()
	fake.downloadResourceUncheckedArgsForCall = append(fake.downloadResourceUncheckedArgsForCall, struct {
		blobstoreID string
		out         io.Writer
	}{blobstoreID, out})
	fake.recordInvocation("DownloadResourceUnchecked", []interface{}{blobstoreID, out})
	fake.downloadResourceUncheckedMutex.Unlock()
	if fake.DownloadResourceUncheckedStub != nil {
		return fake.DownloadResourceUncheckedStub(blobstoreID, out)
	} else {
		return fake.downloadResourceUncheckedReturns.result1
	}
}

func (fake *FakeDirector) DownloadResourceUncheckedCallCount() int {
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	return len(fake.downloadResourceUncheckedArgsForCall)
}

func (fake *FakeDirector) DownloadResourceUncheckedArgsForCall(i int) (string, io.Writer) {
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	return fake.downloadResourceUncheckedArgsForCall[i].blobstoreID, fake.downloadResourceUncheckedArgsForCall[i].out
}

func (fake *FakeDirector) DownloadResourceUncheckedReturns(result1 error) {
	fake.DownloadResourceUncheckedStub = nil
	fake.downloadResourceUncheckedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.isAuthenticatedMutex.RLock()
	defer fake.isAuthenticatedMutex.RUnlock()
	fake.withContextMutex.RLock()
	defer fake.withContextMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.locksMutex.RLock()
	defer fake.locksMutex.RUnlock()
	fake.currentTasksMutex.RLock()
	defer fake.currentTasksMutex.RUnlock()
	fake.recentTasksMutex.RLock()
	defer fake.recentTasksMutex.RUnlock()
	fake.findTaskMutex.RLock()
	defer fake.findTaskMutex.RUnlock()
	fake.findTasksByContextIdMutex.RLock()
	defer fake.findTasksByContextIdMutex.RUnlock()
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	fake.eventMutex.RLock()
	defer fake.eventMutex.RUnlock()
	fake.deploymentsMutex.RLock()
	defer fake.deploymentsMutex.RUnlock()
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	fake.releasesMutex.RLock()
	defer fake.releasesMutex.RUnlock()
	fake.hasReleaseMutex.RLock()
	defer fake.hasReleaseMutex.RUnlock()
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	fake.findReleaseSeriesMutex.RLock()
	defer fake.findReleaseSeriesMutex.RUnlock()
	fake.uploadReleaseURLMutex.RLock()
	defer fake.uploadReleaseURLMutex.RUnlock()
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	fake.matchPackagesMutex.RLock()
	defer fake.matchPackagesMutex.RUnlock()
	fake.stemcellsMutex.RLock()
	defer fake.stemcellsMutex.RUnlock()
	fake.hasStemcellMutex.RLock()
	defer fake.hasStemcellMutex.RUnlock()
	fake.findStemcellMutex.RLock()
	defer fake.findStemcellMutex.RUnlock()
	fake.uploadStemcellURLMutex.RLock()
	defer fake.uploadStemcellURLMutex.RUnlock()
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	fake.latestCloudConfigMutex.RLock()
	defer fake.latestCloudConfigMutex.RUnlock()
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	fake.diffCloudConfigMutex.RLock()
	defer fake.diffCloudConfigMutex.RUnlock()
	fake.latestCPIConfigMutex.RLock()
	defer fake.latestCPIConfigMutex.RUnlock()
	fake.updateCPIConfigMutex.RLock()
	defer fake.updateCPIConfigMutex.RUnlock()
	fake.latestRuntimeConfigMutex.RLock()
	defer fake.latestRuntimeConfigMutex.RUnlock()
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	fake.findOrphanDiskMutex.RLock()
	defer fake.findOrphanDiskMutex.RUnlock()
	fake.orphanDisksMutex.RLock()
	defer fake.orphanDisksMutex.RUnlock()
	fake.orphanDiskMutex.RLock()
	defer fake.orphanDiskMutex.RUnlock()
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeDirector) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ director.Director = new(FakeDirector)
