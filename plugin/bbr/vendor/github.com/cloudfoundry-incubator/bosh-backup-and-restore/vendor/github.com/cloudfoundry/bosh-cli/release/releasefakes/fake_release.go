// This file was generated by counterfeiter
package releasefakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-cli/release"
	"github.com/cloudfoundry/bosh-cli/release/job"
	"github.com/cloudfoundry/bosh-cli/release/license"
	"github.com/cloudfoundry/bosh-cli/release/manifest"
	"github.com/cloudfoundry/bosh-cli/release/pkg"
)

type FakeRelease struct {
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct{}
	nameReturns     struct {
		result1 string
	}
	SetNameStub        func(string)
	setNameMutex       sync.RWMutex
	setNameArgsForCall []struct {
		arg1 string
	}
	VersionStub        func() string
	versionMutex       sync.RWMutex
	versionArgsForCall []struct{}
	versionReturns     struct {
		result1 string
	}
	SetVersionStub        func(string)
	setVersionMutex       sync.RWMutex
	setVersionArgsForCall []struct {
		arg1 string
	}
	CommitHashWithMarkStub        func(string) string
	commitHashWithMarkMutex       sync.RWMutex
	commitHashWithMarkArgsForCall []struct {
		arg1 string
	}
	commitHashWithMarkReturns struct {
		result1 string
	}
	SetCommitHashStub        func(string)
	setCommitHashMutex       sync.RWMutex
	setCommitHashArgsForCall []struct {
		arg1 string
	}
	SetUncommittedChangesStub        func(bool)
	setUncommittedChangesMutex       sync.RWMutex
	setUncommittedChangesArgsForCall []struct {
		arg1 bool
	}
	JobsStub        func() []*job.Job
	jobsMutex       sync.RWMutex
	jobsArgsForCall []struct{}
	jobsReturns     struct {
		result1 []*job.Job
	}
	PackagesStub        func() []*pkg.Package
	packagesMutex       sync.RWMutex
	packagesArgsForCall []struct{}
	packagesReturns     struct {
		result1 []*pkg.Package
	}
	CompiledPackagesStub        func() []*pkg.CompiledPackage
	compiledPackagesMutex       sync.RWMutex
	compiledPackagesArgsForCall []struct{}
	compiledPackagesReturns     struct {
		result1 []*pkg.CompiledPackage
	}
	LicenseStub        func() *license.License
	licenseMutex       sync.RWMutex
	licenseArgsForCall []struct{}
	licenseReturns     struct {
		result1 *license.License
	}
	IsCompiledStub        func() bool
	isCompiledMutex       sync.RWMutex
	isCompiledArgsForCall []struct{}
	isCompiledReturns     struct {
		result1 bool
	}
	FindJobByNameStub        func(string) (job.Job, bool)
	findJobByNameMutex       sync.RWMutex
	findJobByNameArgsForCall []struct {
		arg1 string
	}
	findJobByNameReturns struct {
		result1 job.Job
		result2 bool
	}
	ManifestStub        func() manifest.Manifest
	manifestMutex       sync.RWMutex
	manifestArgsForCall []struct{}
	manifestReturns     struct {
		result1 manifest.Manifest
	}
	BuildStub        func(dev, final release.ArchiveIndicies) error
	buildMutex       sync.RWMutex
	buildArgsForCall []struct {
		dev   release.ArchiveIndicies
		final release.ArchiveIndicies
	}
	buildReturns struct {
		result1 error
	}
	FinalizeStub        func(final release.ArchiveIndicies) error
	finalizeMutex       sync.RWMutex
	finalizeArgsForCall []struct {
		final release.ArchiveIndicies
	}
	finalizeReturns struct {
		result1 error
	}
	CopyWithStub        func(jobs []*job.Job, packages []*pkg.Package, lic *license.License, compiledPackages []*pkg.CompiledPackage) release.Release
	copyWithMutex       sync.RWMutex
	copyWithArgsForCall []struct {
		jobs             []*job.Job
		packages         []*pkg.Package
		lic              *license.License
		compiledPackages []*pkg.CompiledPackage
	}
	copyWithReturns struct {
		result1 release.Release
	}
	CleanUpStub        func() error
	cleanUpMutex       sync.RWMutex
	cleanUpArgsForCall []struct{}
	cleanUpReturns     struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRelease) Name() string {
	fake.nameMutex.Lock()
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct{}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	} else {
		return fake.nameReturns.result1
	}
}

func (fake *FakeRelease) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeRelease) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeRelease) SetName(arg1 string) {
	fake.setNameMutex.Lock()
	fake.setNameArgsForCall = append(fake.setNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetName", []interface{}{arg1})
	fake.setNameMutex.Unlock()
	if fake.SetNameStub != nil {
		fake.SetNameStub(arg1)
	}
}

func (fake *FakeRelease) SetNameCallCount() int {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	return len(fake.setNameArgsForCall)
}

func (fake *FakeRelease) SetNameArgsForCall(i int) string {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	return fake.setNameArgsForCall[i].arg1
}

func (fake *FakeRelease) Version() string {
	fake.versionMutex.Lock()
	fake.versionArgsForCall = append(fake.versionArgsForCall, struct{}{})
	fake.recordInvocation("Version", []interface{}{})
	fake.versionMutex.Unlock()
	if fake.VersionStub != nil {
		return fake.VersionStub()
	} else {
		return fake.versionReturns.result1
	}
}

func (fake *FakeRelease) VersionCallCount() int {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return len(fake.versionArgsForCall)
}

func (fake *FakeRelease) VersionReturns(result1 string) {
	fake.VersionStub = nil
	fake.versionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeRelease) SetVersion(arg1 string) {
	fake.setVersionMutex.Lock()
	fake.setVersionArgsForCall = append(fake.setVersionArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetVersion", []interface{}{arg1})
	fake.setVersionMutex.Unlock()
	if fake.SetVersionStub != nil {
		fake.SetVersionStub(arg1)
	}
}

func (fake *FakeRelease) SetVersionCallCount() int {
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	return len(fake.setVersionArgsForCall)
}

func (fake *FakeRelease) SetVersionArgsForCall(i int) string {
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	return fake.setVersionArgsForCall[i].arg1
}

func (fake *FakeRelease) CommitHashWithMark(arg1 string) string {
	fake.commitHashWithMarkMutex.Lock()
	fake.commitHashWithMarkArgsForCall = append(fake.commitHashWithMarkArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CommitHashWithMark", []interface{}{arg1})
	fake.commitHashWithMarkMutex.Unlock()
	if fake.CommitHashWithMarkStub != nil {
		return fake.CommitHashWithMarkStub(arg1)
	} else {
		return fake.commitHashWithMarkReturns.result1
	}
}

func (fake *FakeRelease) CommitHashWithMarkCallCount() int {
	fake.commitHashWithMarkMutex.RLock()
	defer fake.commitHashWithMarkMutex.RUnlock()
	return len(fake.commitHashWithMarkArgsForCall)
}

func (fake *FakeRelease) CommitHashWithMarkArgsForCall(i int) string {
	fake.commitHashWithMarkMutex.RLock()
	defer fake.commitHashWithMarkMutex.RUnlock()
	return fake.commitHashWithMarkArgsForCall[i].arg1
}

func (fake *FakeRelease) CommitHashWithMarkReturns(result1 string) {
	fake.CommitHashWithMarkStub = nil
	fake.commitHashWithMarkReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeRelease) SetCommitHash(arg1 string) {
	fake.setCommitHashMutex.Lock()
	fake.setCommitHashArgsForCall = append(fake.setCommitHashArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetCommitHash", []interface{}{arg1})
	fake.setCommitHashMutex.Unlock()
	if fake.SetCommitHashStub != nil {
		fake.SetCommitHashStub(arg1)
	}
}

func (fake *FakeRelease) SetCommitHashCallCount() int {
	fake.setCommitHashMutex.RLock()
	defer fake.setCommitHashMutex.RUnlock()
	return len(fake.setCommitHashArgsForCall)
}

func (fake *FakeRelease) SetCommitHashArgsForCall(i int) string {
	fake.setCommitHashMutex.RLock()
	defer fake.setCommitHashMutex.RUnlock()
	return fake.setCommitHashArgsForCall[i].arg1
}

func (fake *FakeRelease) SetUncommittedChanges(arg1 bool) {
	fake.setUncommittedChangesMutex.Lock()
	fake.setUncommittedChangesArgsForCall = append(fake.setUncommittedChangesArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("SetUncommittedChanges", []interface{}{arg1})
	fake.setUncommittedChangesMutex.Unlock()
	if fake.SetUncommittedChangesStub != nil {
		fake.SetUncommittedChangesStub(arg1)
	}
}

func (fake *FakeRelease) SetUncommittedChangesCallCount() int {
	fake.setUncommittedChangesMutex.RLock()
	defer fake.setUncommittedChangesMutex.RUnlock()
	return len(fake.setUncommittedChangesArgsForCall)
}

func (fake *FakeRelease) SetUncommittedChangesArgsForCall(i int) bool {
	fake.setUncommittedChangesMutex.RLock()
	defer fake.setUncommittedChangesMutex.RUnlock()
	return fake.setUncommittedChangesArgsForCall[i].arg1
}

func (fake *FakeRelease) Jobs() []*job.Job {
	fake.jobsMutex.Lock()
	fake.jobsArgsForCall = append(fake.jobsArgsForCall, struct{}{})
	fake.recordInvocation("Jobs", []interface{}{})
	fake.jobsMutex.Unlock()
	if fake.JobsStub != nil {
		return fake.JobsStub()
	} else {
		return fake.jobsReturns.result1
	}
}

func (fake *FakeRelease) JobsCallCount() int {
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	return len(fake.jobsArgsForCall)
}

func (fake *FakeRelease) JobsReturns(result1 []*job.Job) {
	fake.JobsStub = nil
	fake.jobsReturns = struct {
		result1 []*job.Job
	}{result1}
}

func (fake *FakeRelease) Packages() []*pkg.Package {
	fake.packagesMutex.Lock()
	fake.packagesArgsForCall = append(fake.packagesArgsForCall, struct{}{})
	fake.recordInvocation("Packages", []interface{}{})
	fake.packagesMutex.Unlock()
	if fake.PackagesStub != nil {
		return fake.PackagesStub()
	} else {
		return fake.packagesReturns.result1
	}
}

func (fake *FakeRelease) PackagesCallCount() int {
	fake.packagesMutex.RLock()
	defer fake.packagesMutex.RUnlock()
	return len(fake.packagesArgsForCall)
}

func (fake *FakeRelease) PackagesReturns(result1 []*pkg.Package) {
	fake.PackagesStub = nil
	fake.packagesReturns = struct {
		result1 []*pkg.Package
	}{result1}
}

func (fake *FakeRelease) CompiledPackages() []*pkg.CompiledPackage {
	fake.compiledPackagesMutex.Lock()
	fake.compiledPackagesArgsForCall = append(fake.compiledPackagesArgsForCall, struct{}{})
	fake.recordInvocation("CompiledPackages", []interface{}{})
	fake.compiledPackagesMutex.Unlock()
	if fake.CompiledPackagesStub != nil {
		return fake.CompiledPackagesStub()
	} else {
		return fake.compiledPackagesReturns.result1
	}
}

func (fake *FakeRelease) CompiledPackagesCallCount() int {
	fake.compiledPackagesMutex.RLock()
	defer fake.compiledPackagesMutex.RUnlock()
	return len(fake.compiledPackagesArgsForCall)
}

func (fake *FakeRelease) CompiledPackagesReturns(result1 []*pkg.CompiledPackage) {
	fake.CompiledPackagesStub = nil
	fake.compiledPackagesReturns = struct {
		result1 []*pkg.CompiledPackage
	}{result1}
}

func (fake *FakeRelease) License() *license.License {
	fake.licenseMutex.Lock()
	fake.licenseArgsForCall = append(fake.licenseArgsForCall, struct{}{})
	fake.recordInvocation("License", []interface{}{})
	fake.licenseMutex.Unlock()
	if fake.LicenseStub != nil {
		return fake.LicenseStub()
	} else {
		return fake.licenseReturns.result1
	}
}

func (fake *FakeRelease) LicenseCallCount() int {
	fake.licenseMutex.RLock()
	defer fake.licenseMutex.RUnlock()
	return len(fake.licenseArgsForCall)
}

func (fake *FakeRelease) LicenseReturns(result1 *license.License) {
	fake.LicenseStub = nil
	fake.licenseReturns = struct {
		result1 *license.License
	}{result1}
}

func (fake *FakeRelease) IsCompiled() bool {
	fake.isCompiledMutex.Lock()
	fake.isCompiledArgsForCall = append(fake.isCompiledArgsForCall, struct{}{})
	fake.recordInvocation("IsCompiled", []interface{}{})
	fake.isCompiledMutex.Unlock()
	if fake.IsCompiledStub != nil {
		return fake.IsCompiledStub()
	} else {
		return fake.isCompiledReturns.result1
	}
}

func (fake *FakeRelease) IsCompiledCallCount() int {
	fake.isCompiledMutex.RLock()
	defer fake.isCompiledMutex.RUnlock()
	return len(fake.isCompiledArgsForCall)
}

func (fake *FakeRelease) IsCompiledReturns(result1 bool) {
	fake.IsCompiledStub = nil
	fake.isCompiledReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRelease) FindJobByName(arg1 string) (job.Job, bool) {
	fake.findJobByNameMutex.Lock()
	fake.findJobByNameArgsForCall = append(fake.findJobByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindJobByName", []interface{}{arg1})
	fake.findJobByNameMutex.Unlock()
	if fake.FindJobByNameStub != nil {
		return fake.FindJobByNameStub(arg1)
	} else {
		return fake.findJobByNameReturns.result1, fake.findJobByNameReturns.result2
	}
}

func (fake *FakeRelease) FindJobByNameCallCount() int {
	fake.findJobByNameMutex.RLock()
	defer fake.findJobByNameMutex.RUnlock()
	return len(fake.findJobByNameArgsForCall)
}

func (fake *FakeRelease) FindJobByNameArgsForCall(i int) string {
	fake.findJobByNameMutex.RLock()
	defer fake.findJobByNameMutex.RUnlock()
	return fake.findJobByNameArgsForCall[i].arg1
}

func (fake *FakeRelease) FindJobByNameReturns(result1 job.Job, result2 bool) {
	fake.FindJobByNameStub = nil
	fake.findJobByNameReturns = struct {
		result1 job.Job
		result2 bool
	}{result1, result2}
}

func (fake *FakeRelease) Manifest() manifest.Manifest {
	fake.manifestMutex.Lock()
	fake.manifestArgsForCall = append(fake.manifestArgsForCall, struct{}{})
	fake.recordInvocation("Manifest", []interface{}{})
	fake.manifestMutex.Unlock()
	if fake.ManifestStub != nil {
		return fake.ManifestStub()
	} else {
		return fake.manifestReturns.result1
	}
}

func (fake *FakeRelease) ManifestCallCount() int {
	fake.manifestMutex.RLock()
	defer fake.manifestMutex.RUnlock()
	return len(fake.manifestArgsForCall)
}

func (fake *FakeRelease) ManifestReturns(result1 manifest.Manifest) {
	fake.ManifestStub = nil
	fake.manifestReturns = struct {
		result1 manifest.Manifest
	}{result1}
}

func (fake *FakeRelease) Build(dev release.ArchiveIndicies, final release.ArchiveIndicies) error {
	fake.buildMutex.Lock()
	fake.buildArgsForCall = append(fake.buildArgsForCall, struct {
		dev   release.ArchiveIndicies
		final release.ArchiveIndicies
	}{dev, final})
	fake.recordInvocation("Build", []interface{}{dev, final})
	fake.buildMutex.Unlock()
	if fake.BuildStub != nil {
		return fake.BuildStub(dev, final)
	} else {
		return fake.buildReturns.result1
	}
}

func (fake *FakeRelease) BuildCallCount() int {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	return len(fake.buildArgsForCall)
}

func (fake *FakeRelease) BuildArgsForCall(i int) (release.ArchiveIndicies, release.ArchiveIndicies) {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	return fake.buildArgsForCall[i].dev, fake.buildArgsForCall[i].final
}

func (fake *FakeRelease) BuildReturns(result1 error) {
	fake.BuildStub = nil
	fake.buildReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRelease) Finalize(final release.ArchiveIndicies) error {
	fake.finalizeMutex.Lock()
	fake.finalizeArgsForCall = append(fake.finalizeArgsForCall, struct {
		final release.ArchiveIndicies
	}{final})
	fake.recordInvocation("Finalize", []interface{}{final})
	fake.finalizeMutex.Unlock()
	if fake.FinalizeStub != nil {
		return fake.FinalizeStub(final)
	} else {
		return fake.finalizeReturns.result1
	}
}

func (fake *FakeRelease) FinalizeCallCount() int {
	fake.finalizeMutex.RLock()
	defer fake.finalizeMutex.RUnlock()
	return len(fake.finalizeArgsForCall)
}

func (fake *FakeRelease) FinalizeArgsForCall(i int) release.ArchiveIndicies {
	fake.finalizeMutex.RLock()
	defer fake.finalizeMutex.RUnlock()
	return fake.finalizeArgsForCall[i].final
}

func (fake *FakeRelease) FinalizeReturns(result1 error) {
	fake.FinalizeStub = nil
	fake.finalizeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRelease) CopyWith(jobs []*job.Job, packages []*pkg.Package, lic *license.License, compiledPackages []*pkg.CompiledPackage) release.Release {
	var jobsCopy []*job.Job
	if jobs != nil {
		jobsCopy = make([]*job.Job, len(jobs))
		copy(jobsCopy, jobs)
	}
	var packagesCopy []*pkg.Package
	if packages != nil {
		packagesCopy = make([]*pkg.Package, len(packages))
		copy(packagesCopy, packages)
	}
	var compiledPackagesCopy []*pkg.CompiledPackage
	if compiledPackages != nil {
		compiledPackagesCopy = make([]*pkg.CompiledPackage, len(compiledPackages))
		copy(compiledPackagesCopy, compiledPackages)
	}
	fake.copyWithMutex.Lock()
	fake.copyWithArgsForCall = append(fake.copyWithArgsForCall, struct {
		jobs             []*job.Job
		packages         []*pkg.Package
		lic              *license.License
		compiledPackages []*pkg.CompiledPackage
	}{jobsCopy, packagesCopy, lic, compiledPackagesCopy})
	fake.recordInvocation("CopyWith", []interface{}{jobsCopy, packagesCopy, lic, compiledPackagesCopy})
	fake.copyWithMutex.Unlock()
	if fake.CopyWithStub != nil {
		return fake.CopyWithStub(jobs, packages, lic, compiledPackages)
	} else {
		return fake.copyWithReturns.result1
	}
}

func (fake *FakeRelease) CopyWithCallCount() int {
	fake.copyWithMutex.RLock()
	defer fake.copyWithMutex.RUnlock()
	return len(fake.copyWithArgsForCall)
}

func (fake *FakeRelease) CopyWithArgsForCall(i int) ([]*job.Job, []*pkg.Package, *license.License, []*pkg.CompiledPackage) {
	fake.copyWithMutex.RLock()
	defer fake.copyWithMutex.RUnlock()
	return fake.copyWithArgsForCall[i].jobs, fake.copyWithArgsForCall[i].packages, fake.copyWithArgsForCall[i].lic, fake.copyWithArgsForCall[i].compiledPackages
}

func (fake *FakeRelease) CopyWithReturns(result1 release.Release) {
	fake.CopyWithStub = nil
	fake.copyWithReturns = struct {
		result1 release.Release
	}{result1}
}

func (fake *FakeRelease) CleanUp() error {
	fake.cleanUpMutex.Lock()
	fake.cleanUpArgsForCall = append(fake.cleanUpArgsForCall, struct{}{})
	fake.recordInvocation("CleanUp", []interface{}{})
	fake.cleanUpMutex.Unlock()
	if fake.CleanUpStub != nil {
		return fake.CleanUpStub()
	} else {
		return fake.cleanUpReturns.result1
	}
}

func (fake *FakeRelease) CleanUpCallCount() int {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	return len(fake.cleanUpArgsForCall)
}

func (fake *FakeRelease) CleanUpReturns(result1 error) {
	fake.CleanUpStub = nil
	fake.cleanUpReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRelease) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	fake.commitHashWithMarkMutex.RLock()
	defer fake.commitHashWithMarkMutex.RUnlock()
	fake.setCommitHashMutex.RLock()
	defer fake.setCommitHashMutex.RUnlock()
	fake.setUncommittedChangesMutex.RLock()
	defer fake.setUncommittedChangesMutex.RUnlock()
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	fake.packagesMutex.RLock()
	defer fake.packagesMutex.RUnlock()
	fake.compiledPackagesMutex.RLock()
	defer fake.compiledPackagesMutex.RUnlock()
	fake.licenseMutex.RLock()
	defer fake.licenseMutex.RUnlock()
	fake.isCompiledMutex.RLock()
	defer fake.isCompiledMutex.RUnlock()
	fake.findJobByNameMutex.RLock()
	defer fake.findJobByNameMutex.RUnlock()
	fake.manifestMutex.RLock()
	defer fake.manifestMutex.RUnlock()
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	fake.finalizeMutex.RLock()
	defer fake.finalizeMutex.RUnlock()
	fake.copyWithMutex.RLock()
	defer fake.copyWithMutex.RUnlock()
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeRelease) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ release.Release = new(FakeRelease)
