// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/clock"
)

type FakeClock struct {
	NowStub        func() time.Time
	nowMutex       sync.RWMutex
	nowArgsForCall []struct{}
	nowReturns     struct {
		result1 time.Time
	}
	nowReturnsOnCall map[int]struct {
		result1 time.Time
	}
	SleepStub        func(d time.Duration)
	sleepMutex       sync.RWMutex
	sleepArgsForCall []struct {
		d time.Duration
	}
	SinceStub        func(t time.Time) time.Duration
	sinceMutex       sync.RWMutex
	sinceArgsForCall []struct {
		t time.Time
	}
	sinceReturns struct {
		result1 time.Duration
	}
	sinceReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	AfterStub        func(d time.Duration) <-chan time.Time
	afterMutex       sync.RWMutex
	afterArgsForCall []struct {
		d time.Duration
	}
	afterReturns struct {
		result1 <-chan time.Time
	}
	afterReturnsOnCall map[int]struct {
		result1 <-chan time.Time
	}
	NewTimerStub        func(d time.Duration) clock.Timer
	newTimerMutex       sync.RWMutex
	newTimerArgsForCall []struct {
		d time.Duration
	}
	newTimerReturns struct {
		result1 clock.Timer
	}
	newTimerReturnsOnCall map[int]struct {
		result1 clock.Timer
	}
	NewTickerStub        func(d time.Duration) clock.Ticker
	newTickerMutex       sync.RWMutex
	newTickerArgsForCall []struct {
		d time.Duration
	}
	newTickerReturns struct {
		result1 clock.Ticker
	}
	newTickerReturnsOnCall map[int]struct {
		result1 clock.Ticker
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClock) Now() time.Time {
	fake.nowMutex.Lock()
	ret, specificReturn := fake.nowReturnsOnCall[len(fake.nowArgsForCall)]
	fake.nowArgsForCall = append(fake.nowArgsForCall, struct{}{})
	fake.recordInvocation("Now", []interface{}{})
	fake.nowMutex.Unlock()
	if fake.NowStub != nil {
		return fake.NowStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nowReturns.result1
}

func (fake *FakeClock) NowCallCount() int {
	fake.nowMutex.RLock()
	defer fake.nowMutex.RUnlock()
	return len(fake.nowArgsForCall)
}

func (fake *FakeClock) NowReturns(result1 time.Time) {
	fake.NowStub = nil
	fake.nowReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeClock) NowReturnsOnCall(i int, result1 time.Time) {
	fake.NowStub = nil
	if fake.nowReturnsOnCall == nil {
		fake.nowReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.nowReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeClock) Sleep(d time.Duration) {
	fake.sleepMutex.Lock()
	fake.sleepArgsForCall = append(fake.sleepArgsForCall, struct {
		d time.Duration
	}{d})
	fake.recordInvocation("Sleep", []interface{}{d})
	fake.sleepMutex.Unlock()
	if fake.SleepStub != nil {
		fake.SleepStub(d)
	}
}

func (fake *FakeClock) SleepCallCount() int {
	fake.sleepMutex.RLock()
	defer fake.sleepMutex.RUnlock()
	return len(fake.sleepArgsForCall)
}

func (fake *FakeClock) SleepArgsForCall(i int) time.Duration {
	fake.sleepMutex.RLock()
	defer fake.sleepMutex.RUnlock()
	return fake.sleepArgsForCall[i].d
}

func (fake *FakeClock) Since(t time.Time) time.Duration {
	fake.sinceMutex.Lock()
	ret, specificReturn := fake.sinceReturnsOnCall[len(fake.sinceArgsForCall)]
	fake.sinceArgsForCall = append(fake.sinceArgsForCall, struct {
		t time.Time
	}{t})
	fake.recordInvocation("Since", []interface{}{t})
	fake.sinceMutex.Unlock()
	if fake.SinceStub != nil {
		return fake.SinceStub(t)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.sinceReturns.result1
}

func (fake *FakeClock) SinceCallCount() int {
	fake.sinceMutex.RLock()
	defer fake.sinceMutex.RUnlock()
	return len(fake.sinceArgsForCall)
}

func (fake *FakeClock) SinceArgsForCall(i int) time.Time {
	fake.sinceMutex.RLock()
	defer fake.sinceMutex.RUnlock()
	return fake.sinceArgsForCall[i].t
}

func (fake *FakeClock) SinceReturns(result1 time.Duration) {
	fake.SinceStub = nil
	fake.sinceReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeClock) SinceReturnsOnCall(i int, result1 time.Duration) {
	fake.SinceStub = nil
	if fake.sinceReturnsOnCall == nil {
		fake.sinceReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.sinceReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeClock) After(d time.Duration) <-chan time.Time {
	fake.afterMutex.Lock()
	ret, specificReturn := fake.afterReturnsOnCall[len(fake.afterArgsForCall)]
	fake.afterArgsForCall = append(fake.afterArgsForCall, struct {
		d time.Duration
	}{d})
	fake.recordInvocation("After", []interface{}{d})
	fake.afterMutex.Unlock()
	if fake.AfterStub != nil {
		return fake.AfterStub(d)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.afterReturns.result1
}

func (fake *FakeClock) AfterCallCount() int {
	fake.afterMutex.RLock()
	defer fake.afterMutex.RUnlock()
	return len(fake.afterArgsForCall)
}

func (fake *FakeClock) AfterArgsForCall(i int) time.Duration {
	fake.afterMutex.RLock()
	defer fake.afterMutex.RUnlock()
	return fake.afterArgsForCall[i].d
}

func (fake *FakeClock) AfterReturns(result1 <-chan time.Time) {
	fake.AfterStub = nil
	fake.afterReturns = struct {
		result1 <-chan time.Time
	}{result1}
}

func (fake *FakeClock) AfterReturnsOnCall(i int, result1 <-chan time.Time) {
	fake.AfterStub = nil
	if fake.afterReturnsOnCall == nil {
		fake.afterReturnsOnCall = make(map[int]struct {
			result1 <-chan time.Time
		})
	}
	fake.afterReturnsOnCall[i] = struct {
		result1 <-chan time.Time
	}{result1}
}

func (fake *FakeClock) NewTimer(d time.Duration) clock.Timer {
	fake.newTimerMutex.Lock()
	ret, specificReturn := fake.newTimerReturnsOnCall[len(fake.newTimerArgsForCall)]
	fake.newTimerArgsForCall = append(fake.newTimerArgsForCall, struct {
		d time.Duration
	}{d})
	fake.recordInvocation("NewTimer", []interface{}{d})
	fake.newTimerMutex.Unlock()
	if fake.NewTimerStub != nil {
		return fake.NewTimerStub(d)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newTimerReturns.result1
}

func (fake *FakeClock) NewTimerCallCount() int {
	fake.newTimerMutex.RLock()
	defer fake.newTimerMutex.RUnlock()
	return len(fake.newTimerArgsForCall)
}

func (fake *FakeClock) NewTimerArgsForCall(i int) time.Duration {
	fake.newTimerMutex.RLock()
	defer fake.newTimerMutex.RUnlock()
	return fake.newTimerArgsForCall[i].d
}

func (fake *FakeClock) NewTimerReturns(result1 clock.Timer) {
	fake.NewTimerStub = nil
	fake.newTimerReturns = struct {
		result1 clock.Timer
	}{result1}
}

func (fake *FakeClock) NewTimerReturnsOnCall(i int, result1 clock.Timer) {
	fake.NewTimerStub = nil
	if fake.newTimerReturnsOnCall == nil {
		fake.newTimerReturnsOnCall = make(map[int]struct {
			result1 clock.Timer
		})
	}
	fake.newTimerReturnsOnCall[i] = struct {
		result1 clock.Timer
	}{result1}
}

func (fake *FakeClock) NewTicker(d time.Duration) clock.Ticker {
	fake.newTickerMutex.Lock()
	ret, specificReturn := fake.newTickerReturnsOnCall[len(fake.newTickerArgsForCall)]
	fake.newTickerArgsForCall = append(fake.newTickerArgsForCall, struct {
		d time.Duration
	}{d})
	fake.recordInvocation("NewTicker", []interface{}{d})
	fake.newTickerMutex.Unlock()
	if fake.NewTickerStub != nil {
		return fake.NewTickerStub(d)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newTickerReturns.result1
}

func (fake *FakeClock) NewTickerCallCount() int {
	fake.newTickerMutex.RLock()
	defer fake.newTickerMutex.RUnlock()
	return len(fake.newTickerArgsForCall)
}

func (fake *FakeClock) NewTickerArgsForCall(i int) time.Duration {
	fake.newTickerMutex.RLock()
	defer fake.newTickerMutex.RUnlock()
	return fake.newTickerArgsForCall[i].d
}

func (fake *FakeClock) NewTickerReturns(result1 clock.Ticker) {
	fake.NewTickerStub = nil
	fake.newTickerReturns = struct {
		result1 clock.Ticker
	}{result1}
}

func (fake *FakeClock) NewTickerReturnsOnCall(i int, result1 clock.Ticker) {
	fake.NewTickerStub = nil
	if fake.newTickerReturnsOnCall == nil {
		fake.newTickerReturnsOnCall = make(map[int]struct {
			result1 clock.Ticker
		})
	}
	fake.newTickerReturnsOnCall[i] = struct {
		result1 clock.Ticker
	}{result1}
}

func (fake *FakeClock) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.nowMutex.RLock()
	defer fake.nowMutex.RUnlock()
	fake.sleepMutex.RLock()
	defer fake.sleepMutex.RUnlock()
	fake.sinceMutex.RLock()
	defer fake.sinceMutex.RUnlock()
	fake.afterMutex.RLock()
	defer fake.afterMutex.RUnlock()
	fake.newTimerMutex.RLock()
	defer fake.newTimerMutex.RUnlock()
	fake.newTickerMutex.RLock()
	defer fake.newTickerMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClock) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ clock.Clock = new(FakeClock)
